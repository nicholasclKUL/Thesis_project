const char* casadi_axpy_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"axpy\"\n"
  "template<typename T1>\n"
  "void casadi_axpy(casadi_int n, T1 alpha, const T1* x, T1* y) {\n"
  "  casadi_int i;\n"
  "  if (!x || !y) return;\n"
  "  for (i=0; i<n; ++i) *y++ += alpha**x++;\n"
  "}\n";

const char* casadi_bilin_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"bilin\"\n"
  "template<typename T1>\n"
  "T1 casadi_bilin(const T1* A, const casadi_int* sp_A, const T1* x, const T1* y) {\n"
  "  casadi_int ncol_A, cc, rr, el;\n"
  "  const casadi_int *colind_A, *row_A;\n"
  "  T1 ret;\n"
  "  // Get sparsities\n"
  "  ncol_A = sp_A[1];\n"
  "  colind_A = sp_A+2; row_A = sp_A + 2 + ncol_A+1;\n"
  "  // Return value\n"
  "  ret=0;\n"
  "  // Loop over the columns of A\n"
  "  for (cc=0; cc<ncol_A; ++cc) {\n"
  "    // Loop over the nonzeros of A\n"
  "    for (el=colind_A[cc]; el<colind_A[cc+1]; ++el) {\n"
  "      // Get the row\n"
  "      rr=row_A[el];\n"
  "      // Add contribution\n"
  "      ret += x[rr]*A[el]*y[cc];\n"
  "    }\n"
  "  }\n"
  "  return ret;\n"
  "}\n";

const char* casadi_copy_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"copy\"\n"
  "template<typename T1>\n"
  "void casadi_copy(const T1* x, casadi_int n, T1* y) {\n"
  "  casadi_int i;\n"
  "  if (y) {\n"
  "    if (x) {\n"
  "      for (i=0; i<n; ++i) *y++ = *x++;\n"
  "    } else {\n"
  "      for (i=0; i<n; ++i) *y++ = 0.;\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_cvx_str =
  "// NOLINT(legal/copyright)\n"
  "// C-REPLACE \"fmax\" \"casadi_fmax\"\n"
  "// C-REPLACE \"nullptr\" \"0\"\n"
  "// SYMBOL \"cvx_house\"\n"
  "/// Computes Householder vector\n"
  "/// beta: scalar\n"
  "/// v: vector of length nv\n"
  "/// Returns 2-norm of v\n"
  "///\n"
  "/// Ref: Golub & Van Loan Alg 5.1.1\n"
  "template<typename T1>\n"
  "T1 casadi_cvx_house(T1* v, T1* beta, casadi_int nv) {\n"
  "  // Local variable\n"
  "  casadi_int i;\n"
  "  T1 v0, sigma, s, v02;\n"
  "  // Calculate norm\n"
  "  v0 = v[0]; // Save v0 (overwritten below)\n"
  "  sigma=0;\n"
  "  for (i=1; i<nv; ++i) sigma += v[i]*v[i];\n"
  "  s = sqrt(v0*v0 + sigma); // s = norm(v)\n"
  "  if (sigma==0) {\n"
  "    *beta = 0;\n"
  "  } else {\n"
  "    if (v0<=0) {\n"
  "      v0 -= s;\n"
  "    } else {\n"
  "      v0 = -sigma/(v0+s);\n"
  "    }\n"
  "    v02 = v0*v0;\n"
  "    *beta = 2*v02/(sigma+v02);\n"
  "    v[0] = 1;\n"
  "    for (i=1;i<nv;++i) v[i] /= v0;\n"
  "  }\n"
  "  return s;\n"
  "}\n"
  "// SYMBOL \"cvx_house_apply_symm\"\n"
  "// Apply householder transform to a symmetric submatrix\n"
  "// on dense A m-by-n matrix\n"
  "//\n"
  "// A is modified in-place\n"
  "//\n"
  "// s : stride\n"
  "//     normally equal to m\n"
  "//     when A is a submatrix of a bigger matrix, set equal to latter's number of rows\n"
  "// v : compact housholder factorisation (length m)\n"
  "//     First element (always one) is used to store beta\n"
  "// p : length n\n"
  "//\n"
  "// Reference: Golub & Van Loan, Alg. 8.3.1\n"
  "template<typename T1>\n"
  "void casadi_cvx_house_apply_symm(casadi_int n, casadi_int k, T1* A, T1* p, T1* v) {\n"
  "  casadi_int i, j, stride, N;\n"
  "  T1 *a;\n"
  "  T1 beta = v[0];\n"
  "  v[0] = 1;\n"
  "  stride = k+1;\n"
  "  A+= k+1+n*k;\n"
  "  N = n-k-1;\n"
  "  // p <- beta * A(k+1:n,k+1:n) v\n"
  "  casadi_clear(p, N);\n"
  "  a = A+n;\n"
  "  // Loop over columns\n"
  "  for (i=0;i<N;++i) {\n"
  "    p[i] += beta*(*a++)*v[i];\n"
  "    // Loop over rows\n"
  "    for (j=i+1;j<N;++j) {\n"
  "      p[j] += beta*(*a)*v[i];\n"
  "      p[i] += beta*(*a++)*v[j];\n"
  "    }\n"
  "    a += stride+i+1;\n"
  "  }\n"
  "  // p <- p - (beta p'v/2) v\n"
  "  casadi_axpy(N, -beta*casadi_dot(N, p, v)/2, v, p);\n"
  "  // Rank-2 update\n"
  "  a = A+n;\n"
  "  // Loop over columns\n"
  "  for (i=0;i<N;++i) {\n"
  "    *a++ -= 2*v[i]*p[i];\n"
  "    // Loop over rows\n"
  "    for (j=i+1;j<N;++j) {\n"
  "      *a++ -= v[i]*p[j]+v[j]*p[i];\n"
  "    }\n"
  "    a += stride+i+1;\n"
  "  }\n"
  "  v[0] = beta;\n"
  "}\n"
  "// SYMBOL \"cvx_tri\"\n"
  "// Tri-diagonalize a symmetric matrix in-place\n"
  "// Results are in lower-triangular part\n"
  "//\n"
  "// Upper triangular part contains compact housholder factorisations\n"
  "//\n"
  "// A: n-by-n dense\n"
  "// p: work vector; length n\n"
  "template<typename T1>\n"
  "void casadi_cvx_tri(T1* A, casadi_int n, T1* p) {\n"
  "  T1 pp[1000];\n"
  "  casadi_int k, N;\n"
  "  T1 *A_base, *v;\n"
  "  T1 beta;\n"
  "  for (k=0;k<n-2;++k) {\n"
  "    A_base = A+k+1+n*k;\n"
  "    N = n-k-1;\n"
  "    v = A+N*n;\n"
  "    // Compute Householder transformation\n"
  "    casadi_copy(A_base, N, v);\n"
  "    // Assign 2-norm\n"
  "    *A_base = casadi_cvx_house(v, &beta, N);\n"
  "    v[0] = beta;\n"
  "    casadi_cvx_house_apply_symm(n, k, A, pp, v);\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"cvx_givens\"\n"
  "// Ref: Golub & Van Loan Alg. 5.1.3\n"
  "template<typename T1>\n"
  "void casadi_cvx_givens(T1 a, T1 b, T1* c, T1* s) {\n"
  "  T1 r;\n"
  "  if (b==0) {\n"
  "    *c = 1;\n"
  "    *s = 0;\n"
  "  } else {\n"
  "    if (fabs(b)>fabs(a)) {\n"
  "      r = -a/b;\n"
  "      *s = 1/sqrt(1+r*r);\n"
  "      *c = (*s)*r;\n"
  "    } else {\n"
  "      r = -b/a;\n"
  "      *c = 1/sqrt(1+r*r);\n"
  "      *s = (*c)*r;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"cvx_implicit_qr\"\n"
  "// Implicit Symmetric QR step with Wilkinson shift\n"
  "//\n"
  "// Tri-diagonal n-by-n matrix\n"
  "// Diagonal: t_diag (length n)\n"
  "// Off-diagonal: t_off (length n-1)\n"
  "// cs: [c0 s0 c1 s1 ...] length 2*(n-1)\n"
  "// Golub & Van Loan Alg. 8.3.2\n"
  "template<typename T1>\n"
  "void casadi_cvx_implicit_qr(casadi_int n, T1* t_diag, T1* t_off, T1* cs) {\n"
  "  T1 d, mu, to2, x, z, c, s, t1, t2, d0, d1, o0, o1, sd;\n"
  "  casadi_int i;\n"
  "  d = 0.5*(t_diag[n-2]-t_diag[n-1]);\n"
  "  to2 = t_off[n-2]*t_off[n-2];\n"
  "  sd = 1;\n"
  "  if (d<0) sd = -1;\n"
  "  mu = t_diag[n-1]-to2/(d+sd*sqrt(d*d+to2));\n"
  "  x = t_diag[0]-mu;\n"
  "  z = t_off[0];\n"
  "  for (i=0;i<n-1;++i) {\n"
  "    // Compute Givens transformation\n"
  "    casadi_cvx_givens(x, z, &c, &s);\n"
  "    // T = G'TG (worked out with scalars)\n"
  "    d0 = t_diag[i];\n"
  "    d1 = t_diag[i+1];\n"
  "    o0 = t_off[i];\n"
  "    o1 = t_off[i+1];\n"
  "    t1 = d0*c-o0*s;\n"
  "    t2 = o0*c-d1*s;\n"
  "    t_diag[i]   = c*t1-s*t2;\n"
  "    t_off[i]    = s*t1+c*t2;\n"
  "    t_diag[i+1] = d0*s*s+2*s*o0*c+d1*c*c;\n"
  "    t_off[i+1] *= c;\n"
  "    if (i>0) {\n"
  "      t_off[i-1] = t_off[i-1]*c-z*s;\n"
  "    }\n"
  "    x = t_off[i];\n"
  "    z = -s*o1;\n"
  "    if (cs) {\n"
  "      *cs++ = c;\n"
  "      *cs++ = s;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"cvx_symm_schur\"\n"
  "// Eigen-decomposition Q'TQ = D\n"
  "// T tri-diagonal, with:\n"
  "//   - t_diag the diagonal vector (length n)\n"
  "//   - t_off the off-diagonal vector (length n-1)\n"
  "//\n"
  "// Eigenvalues can be read from returned t_diag\n"
  "//\n"
  "// tolerance greater than machine precision\n"
  "//\n"
  "// trace_meta: length 1+3*n_iter\n"
  "// trace: length 2*(n-1)*n_iter\n"
  "//\n"
  "/// Golub & Van Loan Alg. 8.3.3\n"
  "template<typename T1>\n"
  "int casadi_cvx_symm_schur(casadi_int n, T1* t_diag, T1* t_off, T1 tol, casadi_int max_iter,\n"
  "    casadi_int* trace_meta, T1* trace) {\n"
  "  casadi_int i, p, q, sp, sq, trace_offset, nn;\n"
  "  casadi_int* n_iter;\n"
  "  n_iter = trace_meta++;\n"
  "  trace_offset = 0;\n"
  "  q = 0;\n"
  "  *n_iter = 0;\n"
  "  while (q<n) {\n"
  "    if (*n_iter==max_iter) return 1;\n"
  "    // Clip converged entries\n"
  "    for (i=0;i<n-1;++i) {\n"
  "      if (fabs(t_off[i])<=tol*(fabs(t_diag[i])+fabs(t_diag[i+1]))) {\n"
  "        t_off[i] = 0;\n"
  "      }\n"
  "    }\n"
  "    // Determine p, q\n"
  "    p = 0;\n"
  "    q = 0;\n"
  "    sp = 0;\n"
  "    sq = 0;\n"
  "    for (i=0;i<n-1;++i) {\n"
  "      if (t_off[n-i-2]==0 && sq==0) {\n"
  "        q++;\n"
  "      } else {\n"
  "        sq = 1;\n"
  "      }\n"
  "      if (t_off[i]==0 && sp==0) {\n"
  "        p++;\n"
  "      } else {\n"
  "        sp = 1;\n"
  "      }\n"
  "      if (q==n-1) {\n"
  "        q = n;\n"
  "        p = 0;\n"
  "      }\n"
  "    }\n"
  "    nn = n-q-p;\n"
  "    if (q<n) {\n"
  "      casadi_cvx_implicit_qr(nn, t_diag+p, t_off+p, trace ? trace+trace_offset : nullptr);\n"
  "      trace_offset += 2*(nn-1);\n"
  "      if (trace_meta) {\n"
  "        *trace_meta++ = nn;\n"
  "        *trace_meta++ = p;\n"
  "        *trace_meta++ = trace_offset;\n"
  "      }\n"
  "      (*n_iter)++;\n"
  "    }\n"
  "  }\n"
  "  return 0;\n"
  "}\n"
  "// SYMBOL \"cvx_givens_apply\"\n"
  "template<typename T1>\n"
  "void casadi_cvx_givens_apply(casadi_int n, T1* q, T1 c, T1 s, casadi_int p) {\n"
  "  T1 t1, t2, t3, t4, a, b;\n"
  "  casadi_int i;\n"
  "  // Update rows\n"
  "  T1 *m = q;\n"
  "  m += p;\n"
  "  for (i=0;i<p;++i) {\n"
  "    a = m[0];\n"
  "    b = m[1];\n"
  "    m[0] = c*a+s*b;\n"
  "    m[1] = c*b-s*a;\n"
  "    m+=n;\n"
  "  }\n"
  "  // Update central patch\n"
  "  t1 = c*m[0]+s*m[1];\n"
  "  t2 = c*m[1]+s*m[n+1];\n"
  "  t3 = c*m[1]-s*m[0];\n"
  "  t4 = c*m[n+1]-s*m[1];\n"
  "  m[0] = c*t1+s*t2;\n"
  "  m[1] = c*t2-s*t1;\n"
  "  m[n+1] = c*t4-s*t3;\n"
  "  // Update columns\n"
  "  m = q+n*p+p+2;\n"
  "  for (i=0;i<n-p-2;++i) {\n"
  "    a = m[0];\n"
  "    b = m[n];\n"
  "    m[0] = c*a+s*b;\n"
  "    m[n] = c*b-s*a;\n"
  "    m++;\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"cvx_house_apply\"\n"
  "/// Apply householder transform\n"
  "/// on dense A m-by-n matrix\n"
  "///\n"
  "/// A is modified in-place\n"
  "///\n"
  "/// s : stride\n"
  "///     normally equal to m\n"
  "///     when A is a submatrix of a bigger matrix, set equal to latter's number of rows\n"
  "/// v : compact housholder factorisation (length m)\n"
  "///     First element (always one) is used to store beta\n"
  "/// p : length n\n"
  "///\n"
  "template<typename T1>\n"
  "void casadi_cvx_house_apply(casadi_int n, casadi_int m, casadi_int s, T1* A,\n"
  "    T1* p, const T1* v) {\n"
  "  casadi_int i, j;\n"
  "  T1 *a;\n"
  "  T1 beta;\n"
  "  beta = v[0];\n"
  "  // pi <- beta Aji vj\n"
  "  casadi_clear(p, n);\n"
  "  a = A;\n"
  "  // Loop over columns\n"
  "  for (i=0;i<n;++i) {\n"
  "    p[i] += beta*a[0];\n"
  "    // Loop over rows\n"
  "    for (j=1;j<m;++j) {\n"
  "      p[i] += beta*a[j]*v[j];\n"
  "    }\n"
  "    a += s;\n"
  "  }\n"
  "  a = A;\n"
  "  // Loop over columns\n"
  "  for (i=0;i<n;++i) {\n"
  "    a[0] -= p[i];\n"
  "    // Loop over rows\n"
  "    for (j=1;j<m;++j) {\n"
  "      a[j] -= v[j]*p[i];\n"
  "    }\n"
  "    a += s;\n"
  "  }\n"
  "}\n"
  "template<typename T1>\n"
  "T1 casadi_cvx_scalar(T1 epsilon, casadi_int reflect, T1 eig) {\n"
  "  return fmax(epsilon, reflect ? fabs(eig) : eig);\n"
  "}\n"
  "// SYMBOL \"cvx\"\n"
  "// Convexify a dense symmetric Hessian\n"
  "//\n"
  "// w real work vector: length max(n,2*(n-1)*n_iter)\n"
  "// iw integer work vector: 1+3*n_iter\n"
  "//\n"
  "// tol:     tolerance for symmetric schur\n"
  "// epsilon: minimum magnitude of eigenvalues\n"
  "// reflect: when nonzero, reflect negative eigenvalues\n"
  "template<typename T1>\n"
  "int casadi_cvx(casadi_int n, T1 *A, T1 epsilon, T1 tol, casadi_int reflect, casadi_int max_iter,\n"
  "    T1* w, casadi_int* iw) {\n"
  "  casadi_int i, j, k, n_iter, nn, p, trace_offset;\n"
  "  casadi_int *t_meta;\n"
  "  T1 c, s, t_off0;\n"
  "  T1 *cs, *t_diag, *t_off;\n"
  "  // Short-circuit for empty matrices\n"
  "  if (n==0) return 0;\n"
  "  // Short-circuit for scalar matrices\n"
  "  if (n==1) {\n"
  "    A[0] = casadi_cvx_scalar(epsilon, reflect, A[0]);\n"
  "    return 0;\n"
  "  }\n"
  "  casadi_cvx_tri(A, n, w);\n"
  "  for (i=0;i<n;++i) {\n"
  "    for (j=0;j<n;++j) {\n"
  "      if (i-j>=2) {\n"
  "        A[i+j*n] = 0;\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  // Represent tri-diagonal as vector pair (t_diag, t_off)\n"
  "  t_off0 = A[1];\n"
  "  t_diag = A;\n"
  "  t_off = A+n;\n"
  "  for (i=1;i<n;++i) {\n"
  "    t_diag[i] = A[i+n*i];\n"
  "  }\n"
  "  t_off[0] = t_off0;\n"
  "  for (i=1;i<n-1;++i) {\n"
  "    t_off[i] = A[i+1+n*i];\n"
  "  }\n"
  "  // Diagonalize matrix by Symmetric QR\n"
  "  if (casadi_cvx_symm_schur(n, t_diag, t_off, tol, max_iter, iw, w)) return 1;\n"
  "  // Retain diagonals (eigenvalues)\n"
  "  for (i=0;i<n;++i) {\n"
  "    A[i+n*i] = casadi_cvx_scalar(epsilon, reflect, t_diag[i]);\n"
  "  }\n"
  "  // Reset other elements\n"
  "  for (i=0;i<n;++i) {\n"
  "    for (j=i+1;j<n;++j) A[j+i*n] = 0;\n"
  "  }\n"
  "  // Undo Symmetric QR\n"
  "  n_iter = iw[0];\n"
  "  t_meta = iw+3*(n_iter-1)+1;\n"
  "  for (i=0;i<n_iter;++i) {\n"
  "    nn = *t_meta++;\n"
  "    p = *t_meta++;\n"
  "    trace_offset = *t_meta++;\n"
  "    cs = w+trace_offset;\n"
  "    t_meta-= 6;\n"
  "    for (j=0;j<nn-1;j++) {\n"
  "      s = *--cs;\n"
  "      c = *--cs;\n"
  "      casadi_cvx_givens_apply(n, A, c, s, p+nn-j-2);\n"
  "    }\n"
  "  }\n"
  "  // Undo triangularization\n"
  "  for (k = n-3; k>=0; --k) {\n"
  "    casadi_int N = n-k-1;\n"
  "    T1 *v = A+N*n;\n"
  "    casadi_cvx_house_apply_symm(n, k, A, w, v);\n"
  "    casadi_cvx_house_apply(k+1, N, n, A+k+1, w, v);\n"
  "  }\n"
  "  return 0;\n"
  "}\n";

const char* casadi_de_boor_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"de_boor\"\n"
  "template<typename T1>\n"
  "void casadi_de_boor(T1 x, const T1* knots, casadi_int n_knots, casadi_int degree, T1* boor) {\n"
  "  // length boor: n_knots-1\n"
  "  casadi_int d, i;\n"
  "  for (d=1;d<degree+1;++d) {\n"
  "    for (i=0;i<n_knots-d-1;++i) {\n"
  "      T1 b, bottom;\n"
  "      b = 0;\n"
  "      bottom = knots[i + d] - knots[i];\n"
  "      if (bottom) b = (x - knots[i]) * boor[i] / bottom;\n"
  "      bottom = knots[i + d + 1] - knots[i + 1];\n"
  "      if (bottom) b += (knots[i + d + 1] - x) * boor[i + 1] / bottom;\n"
  "      boor[i] = b;\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_densify_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"densify\"\n"
  "template<typename T1, typename T2>\n"
  "void casadi_densify(const T1* x, const casadi_int* sp_x, T2* y, casadi_int tr) {\n"
  "  casadi_int nrow_x, ncol_x, i, el;\n"
  "  const casadi_int *colind_x, *row_x;\n"
  "  // Quick return - output ignored\n"
  "  if (!y) return;\n"
  "  nrow_x = sp_x[0]; ncol_x = sp_x[1];\n"
  "  colind_x = sp_x+2; row_x = sp_x+ncol_x+3;\n"
  "  // Zero out return value\n"
  "  casadi_clear(y, nrow_x*ncol_x);\n"
  "  // Quick return - input is zero\n"
  "  if (!x) return;\n"
  "  // Copy nonzeros\n"
  "  if (tr) {\n"
  "    for (i=0; i<ncol_x; ++i) {\n"
  "      for (el=colind_x[i]; el!=colind_x[i+1]; ++el) {\n"
  "        y[i + row_x[el]*ncol_x] = CASADI_CAST(T2, *x++);\n"
  "      }\n"
  "    }\n"
  "  } else {\n"
  "    for (i=0; i<ncol_x; ++i) {\n"
  "      for (el=colind_x[i]; el!=colind_x[i+1]; ++el) {\n"
  "        y[row_x[el]] = CASADI_CAST(T2, *x++);\n"
  "      }\n"
  "      y += nrow_x;\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_dot_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"dot\"\n"
  "template<typename T1>\n"
  "T1 casadi_dot(casadi_int n, const T1* x, const T1* y) {\n"
  "  casadi_int i;\n"
  "  T1 r = 0;\n"
  "  for (i=0; i<n; ++i) r += *x++ * *y++;\n"
  "  return r;\n"
  "}\n";

const char* casadi_clear_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"clear\"\n"
  "template<typename T1>\n"
  "void casadi_clear(T1* x, casadi_int n) {\n"
  "  casadi_int i;\n"
  "  if (x) {\n"
  "    for (i=0; i<n; ++i) *x++ = 0;\n"
  "  }\n"
  "}\n";

const char* casadi_fill_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"fill\"\n"
  "template<typename T1>\n"
  "void casadi_fill(T1* x, casadi_int n, T1 alpha) {\n"
  "  casadi_int i;\n"
  "  if (x) {\n"
  "    for (i=0; i<n; ++i) *x++ = alpha;\n"
  "  }\n"
  "}\n";

const char* casadi_flip_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"flip\"\n"
  "inline\n"
  "casadi_int casadi_flip(casadi_int* corner, casadi_int ndim) {\n"
  "  casadi_int i;\n"
  "  for (i=0; i<ndim; ++i) {\n"
  "    if (corner[i]) {\n"
  "      corner[i]=0;\n"
  "    } else {\n"
  "      corner[i]=1;\n"
  "      return 1;\n"
  "    }\n"
  "  }\n"
  "  return 0;\n"
  "}\n";

const char* casadi_file_slurp_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"file_slurp\"\n"
  "template <typename T1>\n"
  "int casadi_file_slurp(const char* fname, casadi_int n, T1* x) {\n"
  "  casadi_int i;\n"
  "  FILE *fp;\n"
  "  fp = fopen(fname, \"r\");\n"
  "  if (!fp) return 1;\n"
  "  for (i=0;i<n;++i) {\n"
  "    if (fscanf(fp, \"%lg\", x++)<=0) return 2;\n"
  "  }\n"
  "  fclose(fp);\n"
  "  return 0;\n"
  "}\n";

const char* casadi_getu_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"getu\"\n"
  "template<typename T1>\n"
  "void casadi_getu(const T1* x, const casadi_int* sp_x, T1* v) {\n"
  "  casadi_int ncol_x, cc, el;\n"
  "  const casadi_int *colind_x, *row_x;\n"
  "  // Get sparsities\n"
  "  ncol_x = sp_x[1];\n"
  "  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;\n"
  "  // Loop over the columns of x\n"
  "  for (cc=0; cc<ncol_x; ++cc) {\n"
  "    // Loop over the nonzeros of x\n"
  "    for (el=colind_x[cc]; el<colind_x[cc+1] && row_x[el]<=cc; ++el) {\n"
  "      *v++ = x[el];\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_iamax_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"iamax\"\n"
  "template<typename T1>\n"
  "casadi_int casadi_iamax(casadi_int n, const T1* x, casadi_int inc_x) {\n"
  "  casadi_int largest_index, i;\n"
  "  T1 t, largest_value;\n"
  "  largest_value = -1.0;\n"
  "  largest_index = -1;\n"
  "  for (i=0; i<n; ++i) {\n"
  "    t = fabs(*x);\n"
  "    x += inc_x;\n"
  "    if (t>largest_value) {\n"
  "      largest_value = t;\n"
  "      largest_index = i;\n"
  "    }\n"
  "  }\n"
  "  return largest_index;\n"
  "}\n";

const char* casadi_interpn_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"interpn\"\n"
  "template<typename T1>\n"
  "void casadi_interpn(T1* res, casadi_int ndim, const T1* grid, const casadi_int* offset, const T1* values, const T1* x, const casadi_int* lookup_mode, casadi_int m, casadi_int* iw, T1* w) { // NOLINT(whitespace/line_length)\n"
  "  // Work vectors\n"
  "  T1* alpha;\n"
  "  casadi_int *index, *corner;\n"
  "  alpha = w; w += ndim;\n"
  "  index = iw; iw += ndim;\n"
  "  corner = iw; iw += ndim;\n"
  "  // Left index and fraction of interval\n"
  "  casadi_interpn_weights(ndim, grid, offset, x, alpha, index, lookup_mode);\n"
  "  // Loop over all corners, add contribution to output\n"
  "  casadi_clear_casadi_int(corner, ndim);\n"
  "  casadi_clear(res, m);\n"
  "  do {\n"
  "    T1* coeff = 0;\n"
  "    casadi_interpn_interpolate(res, ndim, offset, values,\n"
  "      alpha, index, corner, coeff, m);\n"
  "  } while (casadi_flip(corner, ndim));\n"
  "}\n";

const char* casadi_interpn_grad_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"interpn_grad\"\n"
  "template<typename T1>\n"
  "void casadi_interpn_grad(T1* grad, casadi_int ndim, const T1* grid, const casadi_int* offset, const T1* values, const T1* x, const casadi_int* lookup_mode, casadi_int m, casadi_int* iw, T1* w) { // NOLINT(whitespace/line_length)\n"
  "  T1 *alpha, *coeff, *v;\n"
  "  casadi_int *index, *corner;\n"
  "  casadi_int i;\n"
  "  // Quick return\n"
  "  if (!grad) return;\n"
  "  // Work vectors\n"
  "  alpha = w; w += ndim;\n"
  "  coeff = w; w += ndim;\n"
  "  v = w; w+= m;\n"
  "  index = iw; iw += ndim;\n"
  "  corner = iw; iw += ndim;\n"
  "  // Left index and fraction of interval\n"
  "  casadi_interpn_weights(ndim, grid, offset, x, alpha, index, lookup_mode);\n"
  "  // Loop over all corners, add contribution to output\n"
  "  casadi_clear_casadi_int(corner, ndim);\n"
  "  casadi_clear(grad, ndim*m);\n"
  "  do {\n"
  "    casadi_int i, j;\n"
  "    // Get coefficients\n"
  "    casadi_clear(v, m);\n"
  "    casadi_interpn_interpolate(v, ndim, offset, values,\n"
  "      alpha, index, corner, coeff, m);\n"
  "    // Propagate to alpha\n"
  "    for (i=ndim-1; i>=0; --i) {\n"
  "      if (corner[i]) {\n"
  "        for (j=0; j<m; ++j) {\n"
  "          grad[i*m+j] += v[j]*coeff[i];\n"
  "          v[j] *= alpha[i];\n"
  "        }\n"
  "      } else {\n"
  "        for (j=0; j<m; ++j) {\n"
  "          grad[i*m+j] -= v[j]*coeff[i];\n"
  "          v[j] *= 1-alpha[i];\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  } while (casadi_flip(corner, ndim));\n"
  "  // Propagate to x\n"
  "  for (i=0; i<ndim; ++i) {\n"
  "    casadi_int k, j;\n"
  "    const T1* g;\n"
  "    T1 delta;\n"
  "    g = grid + offset[i];\n"
  "    j = index[i];\n"
  "    delta =  g[j+1]-g[j];\n"
  "    for (k=0;k<m;++k) grad[k] /= delta;\n"
  "    grad += m;\n"
  "  }\n"
  "}\n";

const char* casadi_interpn_interpolate_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"interpn_interpolate\"\n"
  "template<typename T1>\n"
  "void casadi_interpn_interpolate(T1* res, casadi_int ndim, const casadi_int* offset, const T1* values, const T1* alpha, const casadi_int* index, const casadi_int* corner, T1* coeff, casadi_int m) { // NOLINT(whitespace/line_length)\n"
  "  T1 c;\n"
  "  casadi_int ld, i;\n"
  "  // Get weight and value for corner\n"
  "  c=1;\n"
  "  ld=1; // leading dimension\n"
  "  for (i=0; i<ndim; ++i) {\n"
  "    if (coeff) *coeff++ = c;\n"
  "    if (corner[i]) {\n"
  "      c *= alpha[i];\n"
  "    } else {\n"
  "      c *= 1-alpha[i];\n"
  "    }\n"
  "    values += (index[i]+corner[i])*ld*m;\n"
  "    ld *= offset[i+1]-offset[i];\n"
  "  }\n"
  "  if (coeff) {\n"
  "    for (i=0;i<m;++i) res[i] += values[i];\n"
  "  } else {\n"
  "    for (i=0;i<m;++i) res[i] += c*values[i];\n"
  "  }\n"
  "}\n";

const char* casadi_interpn_weights_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"interpn_weights\"\n"
  "template<typename T1>\n"
  "void casadi_interpn_weights(casadi_int ndim, const T1* grid, const casadi_int* offset, const T1* x, T1* alpha, casadi_int* index, const casadi_int* lookup_mode) { // NOLINT(whitespace/line_length)\n"
  "  // Left index and fraction of interval\n"
  "  casadi_int i;\n"
  "  for (i=0; i<ndim; ++i) {\n"
  "    casadi_int ng, j;\n"
  "    T1 xi;\n"
  "    const T1* g;\n"
  "    // Grid point\n"
  "    xi = x ? x[i] : 0;\n"
  "    // Grid\n"
  "    g = grid + offset[i];\n"
  "    ng = offset[i+1]-offset[i];\n"
  "    // Find left index\n"
  "    j = index[i] = casadi_low(xi, g, ng, lookup_mode[i]);\n"
  "    // Get interpolation/extrapolation alpha\n"
  "    alpha[i] = (xi-g[j])/(g[j+1]-g[j]);\n"
  "  }\n"
  "}\n";

const char* casadi_kron_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"kron\"\n"
  "template<typename T1>\n"
  "void casadi_kron(const T1* a, const casadi_int* sp_a, const T1* b, const casadi_int* sp_b, T1* r) {\n"
  "    casadi_int a_ncol, b_ncol, k;\n"
  "    const casadi_int *a_colind, *b_colind;\n"
  "    T1 a_v, b_v;\n"
  "    k = 0;\n"
  "    a_ncol = sp_a[1];\n"
  "    a_colind = sp_a+2;\n"
  "    b_ncol = sp_b[1];\n"
  "    b_colind = sp_b+2;\n"
  "    // Loop over the columns\n"
  "    for (casadi_int a_cc=0; a_cc<a_ncol; ++a_cc) {\n"
  "      // Loop over the columns\n"
  "      for (casadi_int b_cc=0; b_cc<b_ncol; ++b_cc) {\n"
  "        // Loop over existing nonzeros\n"
  "        for (casadi_int a_el=a_colind[a_cc]; a_el<a_colind[a_cc+1]; ++a_el) {\n"
  "          a_v = a[a_el];\n"
  "          // Loop over existing nonzeros\n"
  "          for (casadi_int b_el=b_colind[b_cc]; b_el<b_colind[b_cc+1]; ++b_el) {\n"
  "            b_v = b[b_el];\n"
  "            r[k++] = a_v*b_v;\n"
  "          }\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "}\n";

const char* casadi_low_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"low\"\n"
  "template<typename T1>\n"
  "casadi_int casadi_low(T1 x, const T1* grid, casadi_int ng, casadi_int lookup_mode) {\n"
  "  switch (lookup_mode) {\n"
  "    case 1:\n"
  "      {\n"
  "        T1 g0, dg;\n"
  "        casadi_int ret;\n"
  "        g0 = grid[0];\n"
  "        dg = grid[ng-1]-g0;\n"
  "        ret = (casadi_int) ((x-g0)*(ng-1)/dg); // NOLINT(readability/casting)\n"
  "        if (ret<0) ret=0;\n"
  "        if (ret>ng-2) ret=ng-2;\n"
  "        return ret;\n"
  "      }\n"
  "    case 2:\n"
  "      {\n"
  "        casadi_int start, stop, pivot;\n"
  "        // Quick return\n"
  "        if (ng<2 || x<grid[1]) return 0;\n"
  "        if (x>grid[ng-1]) return ng-2;\n"
  "        start = 0;\n"
  "        stop  = ng-1;\n"
  "        while (1) {\n"
  "          pivot = (stop+start)/2;\n"
  "          if (x < grid[pivot]) {\n"
  "            if (pivot==stop) return pivot;\n"
  "            stop = pivot;\n"
  "          } else {\n"
  "            if (pivot==start) return pivot;\n"
  "            start = pivot;\n"
  "          }\n"
  "        }\n"
  "      }\n"
  "    default: // linear\n"
  "      {\n"
  "        casadi_int i;\n"
  "        for (i=0; i<ng-2; ++i) {\n"
  "          if (x < grid[i+1]) break;\n"
  "        }\n"
  "        return i;\n"
  "      }\n"
  "  }\n"
  "}\n";

const char* casadi_max_viol_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"max_viol\"\n"
  "template<typename T1>\n"
  "T1 casadi_max_viol(casadi_int n, const T1* x, const T1* lb, const T1* ub) {\n"
  "  T1 r;\n"
  "  casadi_int i;\n"
  "  const T1 zero = 0;\n"
  "  r = 0;\n"
  "  for (i=0; i<n; ++i) {\n"
  "    T1 x_i, lb_i, ub_i;\n"
  "    x_i = x ? *x++ : zero;\n"
  "    lb_i = lb ? *lb++ : zero;\n"
  "    ub_i = ub ? *ub++ : zero;\n"
  "    r = fmax(r, fmax(x_i-ub_i, zero));\n"
  "    r = fmax(r, fmax(lb_i-x_i, zero));\n"
  "  }\n"
  "  return r;\n"
  "}\n";

const char* casadi_minmax_str =
  "// NOLINT(legal/copyright)\n"
  "// C-REPLACE \"std::numeric_limits<double>::infinity()\" \"INF\"\n"
  "// SYMBOL \"mmin\"\n"
  "template<typename T1>\n"
  "T1 casadi_mmin(const T1* x, casadi_int n, casadi_int is_dense) {\n"
  "  T1 r = is_dense ? std::numeric_limits<double>::infinity() : 0;\n"
  "  if (!x) return r;\n"
  "  return casadi_vfmin(x, n, r);\n"
  "}\n"
  "// SYMBOL \"mmax\"\n"
  "template<typename T1>\n"
  "T1 casadi_mmax(const T1* x, casadi_int n, casadi_int is_dense) {\n"
  "  T1 r = is_dense ? -std::numeric_limits<double>::infinity() : 0;\n"
  "  if (!x) return r;\n"
  "  return casadi_vfmax(x, n, r);\n"
  "}\n";

const char* casadi_mtimes_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"mtimes\"\n"
  "template<typename T1>\n"
  "void casadi_mtimes(const T1* x, const casadi_int* sp_x, const T1* y, const casadi_int* sp_y, T1* z, const casadi_int* sp_z, T1* w, casadi_int tr) { // NOLINT(whitespace/line_length)\n"
  "  casadi_int ncol_x, ncol_y, ncol_z, cc;\n"
  "  const casadi_int *colind_x, *row_x, *colind_y, *row_y, *colind_z, *row_z;\n"
  "  // Get sparsities\n"
  "  ncol_x = sp_x[1];\n"
  "  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;\n"
  "  ncol_y = sp_y[1];\n"
  "  colind_y = sp_y+2; row_y = sp_y + 2 + ncol_y+1;\n"
  "  ncol_z = sp_z[1];\n"
  "  colind_z = sp_z+2; row_z = sp_z + 2 + ncol_z+1;\n"
  "  if (tr) {\n"
  "    // Loop over the columns of y and z\n"
  "    for (cc=0; cc<ncol_z; ++cc) {\n"
  "      casadi_int kk;\n"
  "      // Get the dense column of y\n"
  "      for (kk=colind_y[cc]; kk<colind_y[cc+1]; ++kk) {\n"
  "        w[row_y[kk]] = y[kk];\n"
  "      }\n"
  "      // Loop over the nonzeros of z\n"
  "      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {\n"
  "        casadi_int kk1;\n"
  "        casadi_int rr = row_z[kk];\n"
  "        // Loop over corresponding columns of x\n"
  "        for (kk1=colind_x[rr]; kk1<colind_x[rr+1]; ++kk1) {\n"
  "          z[kk] += x[kk1] * w[row_x[kk1]];\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  } else {\n"
  "    // Loop over the columns of y and z\n"
  "    for (cc=0; cc<ncol_y; ++cc) {\n"
  "      casadi_int kk;\n"
  "      // Get the dense column of z\n"
  "      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {\n"
  "        w[row_z[kk]] = z[kk];\n"
  "      }\n"
  "      // Loop over the nonzeros of y\n"
  "      for (kk=colind_y[cc]; kk<colind_y[cc+1]; ++kk) {\n"
  "        casadi_int kk1;\n"
  "        casadi_int rr = row_y[kk];\n"
  "        // Loop over corresponding columns of x\n"
  "        for (kk1=colind_x[rr]; kk1<colind_x[rr+1]; ++kk1) {\n"
  "          w[row_x[kk1]] += x[kk1]*y[kk];\n"
  "        }\n"
  "      }\n"
  "      // Get the sparse column of z\n"
  "      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {\n"
  "        z[kk] = w[row_z[kk]];\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_vfmin_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"vfmin\"\n"
  "template<typename T1>\n"
  "T1 casadi_vfmin(const T1* x, casadi_int n, T1 r) {\n"
  "  casadi_int i;\n"
  "  // C-REPLACE \"fmin\" \"casadi_fmin\"\n"
  "  for (i=0; i<n; ++i) r = fmin(r, x[i]);\n"
  "  return r;\n"
  "}\n";

const char* casadi_vfmax_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"vfmax\"\n"
  "template<typename T1>\n"
  "T1 casadi_vfmax(const T1* x, casadi_int n, T1 r) {\n"
  "  casadi_int i;\n"
  "  // C-REPLACE \"fmax\" \"casadi_fmax\"\n"
  "  for (i=0; i<n; ++i) r = fmax(r, x[i]);\n"
  "  return r;\n"
  "}\n";

const char* casadi_mv_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"mv\"\n"
  "template<typename T1>\n"
  "void casadi_mv(const T1* x, const casadi_int* sp_x, const T1* y, T1* z, casadi_int tr) {\n"
  "  casadi_int ncol_x, i, el;\n"
  "  const casadi_int *colind_x, *row_x;\n"
  "  if (!x || !y || !z) return;\n"
  "  // Get sparsities\n"
  "  ncol_x = sp_x[1];\n"
  "  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;\n"
  "  if (tr) {\n"
  "    // loop over the columns of x\n"
  "    for (i=0; i<ncol_x; ++i) {\n"
  "      // loop over the non-zeros of x\n"
  "      for (el=colind_x[i]; el<colind_x[i+1]; ++el) {\n"
  "        z[i] += x[el] * y[row_x[el]];\n"
  "      }\n"
  "    }\n"
  "  } else {\n"
  "    // loop over the columns of x\n"
  "    for (i=0; i<ncol_x; ++i) {\n"
  "      // loop over the non-zeros of x\n"
  "      for (el=colind_x[i]; el<colind_x[i+1]; ++el) {\n"
  "        z[row_x[el]] += x[el] * y[i];\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_mv_dense_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"mv_dense\"\n"
  "template<typename T1>\n"
  "void casadi_mv_dense(const T1* x, casadi_int nrow_x, casadi_int ncol_x,\n"
  "    const T1* y, T1* z, casadi_int tr) {\n"
  "  casadi_int i, j;\n"
  "  if (!x || !y || !z) return;\n"
  "  if (tr) {\n"
  "    for (i=0; i<ncol_x; ++i) {\n"
  "      for (j=0; j<nrow_x; ++j) {\n"
  "        z[i] += *x++ * y[j];\n"
  "      }\n"
  "    }\n"
  "  } else {\n"
  "    for (i=0; i<ncol_x; ++i) {\n"
  "      for (j=0; j<nrow_x; ++j) {\n"
  "        z[j] += *x++ * y[i];\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_nd_boor_eval_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"nd_boor_eval\"\n"
  "template<typename T1>\n"
  "void casadi_nd_boor_eval(T1* ret, casadi_int n_dims, const T1* all_knots, const casadi_int* offset, const casadi_int* all_degree, const casadi_int* strides, const T1* c, casadi_int m, const T1* all_x, const casadi_int* lookup_mode, casadi_int* iw, T1* w) { // NOLINT(whitespace/line_length)\n"
  "  casadi_int n_iter, k, i, pivot;\n"
  "  casadi_int *boor_offset, *starts, *index, *coeff_offset;\n"
  "  T1 *cumprod, *all_boor;\n"
  "  boor_offset = iw; iw+=n_dims+1;\n"
  "  starts = iw; iw+=n_dims;\n"
  "  index = iw; iw+=n_dims;\n"
  "  coeff_offset = iw;\n"
  "  cumprod = w; w+= n_dims+1;\n"
  "  all_boor = w;\n"
  "  boor_offset[0] = 0;\n"
  "  cumprod[n_dims] = 1;\n"
  "  coeff_offset[n_dims] = 0;\n"
  "  n_iter = 1;\n"
  "  for (k=0;k<n_dims;++k) {\n"
  "    T1 *boor;\n"
  "    const T1* knots;\n"
  "    T1 x;\n"
  "    casadi_int degree, n_knots, n_b, L, start;\n"
  "    boor = all_boor+boor_offset[k];\n"
  "    degree = all_degree[k];\n"
  "    knots = all_knots + offset[k];\n"
  "    n_knots = offset[k+1]-offset[k];\n"
  "    n_b = n_knots-degree-1;\n"
  "    x = all_x[k];\n"
  "    L = casadi_low(x, knots+degree, n_knots-2*degree, lookup_mode[k]);\n"
  "    start = L;\n"
  "    if (start>n_b-degree-1) start = n_b-degree-1;\n"
  "    starts[k] = start;\n"
  "    casadi_clear(boor, 2*degree+1);\n"
  "    if (x>=knots[0] && x<=knots[n_knots-1]) {\n"
  "      if (x==knots[1]) {\n"
  "        casadi_fill(boor, degree+1, 1.0);\n"
  "      } else if (x==knots[n_knots-1]) {\n"
  "        boor[degree] = 1;\n"
  "      } else if (knots[L+degree]==x) {\n"
  "        boor[degree-1] = 1;\n"
  "      } else {\n"
  "        boor[degree] = 1;\n"
  "      }\n"
  "    }\n"
  "    casadi_de_boor(x, knots+start, 2*degree+2, degree, boor);\n"
  "    boor+= degree+1;\n"
  "    n_iter*= degree+1;\n"
  "    boor_offset[k+1] = boor_offset[k] + degree+1;\n"
  "  }\n"
  "  casadi_clear_casadi_int(index, n_dims);\n"
  "  // Prepare cumulative product\n"
  "  for (pivot=n_dims-1;pivot>=0;--pivot) {\n"
  "    cumprod[pivot] = (*(all_boor+boor_offset[pivot]))*cumprod[pivot+1];\n"
  "    coeff_offset[pivot] = starts[pivot]*strides[pivot]+coeff_offset[pivot+1];\n"
  "  }\n"
  "  for (k=0;k<n_iter;++k) {\n"
  "    casadi_int pivot = 0;\n"
  "    // accumulate result\n"
  "    for (i=0;i<m;++i) ret[i] += c[coeff_offset[0]+i]*cumprod[0];\n"
  "    // Increment index\n"
  "    index[0]++;\n"
  "    // Handle index overflow\n"
  "    {\n"
  "      // increment next index (forward)\n"
  "      while (index[pivot]==boor_offset[pivot+1]-boor_offset[pivot]) {\n"
  "        index[pivot] = 0;\n"
  "        if (pivot==n_dims-1) break;\n"
  "        index[++pivot]++;\n"
  "      }\n"
  "      // update cumulative structures (reverse)\n"
  "      while (pivot>0) {\n"
  "        // Compute product\n"
  "        cumprod[pivot] = (*(all_boor+boor_offset[pivot]+index[pivot]))*cumprod[pivot+1];\n"
  "        // Compute offset\n"
  "        coeff_offset[pivot] = (starts[pivot]+index[pivot])*strides[pivot]+coeff_offset[pivot+1];\n"
  "        pivot--;\n"
  "      }\n"
  "    }\n"
  "    // Compute product\n"
  "    cumprod[0] = (*(all_boor+index[0]))*cumprod[1];\n"
  "    // Compute offset\n"
  "    coeff_offset[0] = (starts[0]+index[0])*m+coeff_offset[1];\n"
  "  }\n"
  "}\n";

const char* casadi_nd_boor_dual_eval_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"nd_boor_dual_eval\"\n"
  "template<typename T1>\n"
  "casadi_int casadi_nd_boor_dual_eval(T1* val, casadi_int* nz, casadi_int n_dims, const T1* all_knots, const casadi_int* offset, const casadi_int* all_degree, const casadi_int* strides, const T1* all_x, const casadi_int* lookup_mode, casadi_int* iw, T1* w) { // NOLINT(whitespace/line_length)\n"
  "  casadi_int n_iter, k, pivot, nnz;\n"
  "  casadi_int *boor_offset, *starts, *index, *coeff_offset;\n"
  "  T1 *cumprod, *all_boor;\n"
  "  boor_offset = iw; iw+=n_dims+1;\n"
  "  starts = iw; iw+=n_dims;\n"
  "  index = iw; iw+=n_dims;\n"
  "  coeff_offset = iw;\n"
  "  cumprod = w; w+= n_dims+1;\n"
  "  all_boor = w;\n"
  "  boor_offset[0] = 0;\n"
  "  cumprod[n_dims] = 1;\n"
  "  coeff_offset[n_dims] = 0;\n"
  "  nnz = 0;\n"
  "  n_iter = 1;\n"
  "  for (k=0;k<n_dims;++k) {\n"
  "    T1 *boor;\n"
  "    const T1* knots;\n"
  "    T1 x;\n"
  "    casadi_int degree, n_knots, n_b, L, start;\n"
  "    boor = all_boor+boor_offset[k];\n"
  "    degree = all_degree[k];\n"
  "    knots = all_knots + offset[k];\n"
  "    n_knots = offset[k+1]-offset[k];\n"
  "    n_b = n_knots-degree-1;\n"
  "    x = all_x[k];\n"
  "    L = casadi_low(x, knots+degree, n_knots-2*degree, lookup_mode[k]);\n"
  "    start = L;\n"
  "    if (start>n_b-degree-1) start = n_b-degree-1;\n"
  "    starts[k] = start;\n"
  "    casadi_clear(boor, 2*degree+1);\n"
  "    if (x>=knots[0] && x<=knots[n_knots-1]) {\n"
  "      if (x==knots[1]) {\n"
  "        casadi_fill(boor, degree+1, 1.0);\n"
  "      } else if (x==knots[n_knots-1]) {\n"
  "        boor[degree] = 1;\n"
  "      } else if (knots[L+degree]==x) {\n"
  "        boor[degree-1] = 1;\n"
  "      } else {\n"
  "        boor[degree] = 1;\n"
  "      }\n"
  "    }\n"
  "    casadi_de_boor(x, knots+start, 2*degree+2, degree, boor);\n"
  "    boor+= degree+1;\n"
  "    n_iter*= degree+1;\n"
  "    boor_offset[k+1] = boor_offset[k] + degree+1;\n"
  "  }\n"
  "  casadi_clear_casadi_int(index, n_dims);\n"
  "  // Prepare cumulative product\n"
  "  for (pivot=n_dims-1;pivot>=0;--pivot) {\n"
  "    cumprod[pivot] = (*(all_boor+boor_offset[pivot]))*cumprod[pivot+1];\n"
  "    coeff_offset[pivot] = starts[pivot]*strides[pivot]+coeff_offset[pivot+1];\n"
  "  }\n"
  "  for (k=0;k<n_iter;++k) {\n"
  "    casadi_int pivot = 0;\n"
  "    // accumulate result\n"
  "    nz[nnz] = coeff_offset[0];\n"
  "    val[nnz++] += cumprod[0];\n"
  "    // Increment index\n"
  "    index[0]++;\n"
  "    // Handle index overflow\n"
  "    {\n"
  "      // increment next index (forward)\n"
  "      while (index[pivot]==boor_offset[pivot+1]-boor_offset[pivot]) {\n"
  "        index[pivot] = 0;\n"
  "        if (pivot==n_dims-1) break;\n"
  "        index[++pivot]++;\n"
  "      }\n"
  "      // update cumulative structures (reverse)\n"
  "      while (pivot>0) {\n"
  "        // Compute product\n"
  "        cumprod[pivot] = (*(all_boor+boor_offset[pivot]+index[pivot]))*cumprod[pivot+1];\n"
  "        // Compute offset\n"
  "        coeff_offset[pivot] = (starts[pivot]+index[pivot])*strides[pivot]+coeff_offset[pivot+1];\n"
  "        pivot--;\n"
  "      }\n"
  "    }\n"
  "    // Compute product\n"
  "    cumprod[0] = (*(all_boor+index[0]))*cumprod[1];\n"
  "    // Compute offset\n"
  "    coeff_offset[0] = starts[0]+index[0]+coeff_offset[1];\n"
  "  }\n"
  "  return nnz;\n"
  "}\n";

const char* casadi_norm_1_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"norm_1\"\n"
  "template<typename T1>\n"
  "T1 casadi_norm_1(casadi_int n, const T1* x) {\n"
  "  casadi_int i;\n"
  "  T1 ret = 0;\n"
  "  if (x) {\n"
  "    for (i=0; i<n; ++i) ret += fabs(*x++);\n"
  "  }\n"
  "  return ret;\n"
  "}\n";

const char* casadi_norm_2_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"norm_2\"\n"
  "template<typename T1>\n"
  "T1 casadi_norm_2(casadi_int n, const T1* x) {\n"
  "  return sqrt(casadi_dot(n, x, x));\n"
  "}\n";

const char* casadi_norm_inf_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"norm_inf\"\n"
  "template<typename T1>\n"
  "T1 casadi_norm_inf(casadi_int n, const T1* x) {\n"
  "  casadi_int i;\n"
  "  T1 ret = 0;\n"
  "// C-REPLACE \"fmax\" \"casadi_fmax\"\n"
  "  for (i=0; i<n; ++i) ret = fmax(ret, fabs(*x++));\n"
  "  return ret;\n"
  "}\n";

const char* casadi_norm_inf_mul_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"norm_inf_mul\"\n"
  "template<typename T1>\n"
  "T1 casadi_norm_inf_mul(const T1* x, const casadi_int* sp_x, const T1* y, const casadi_int* sp_y, T1* dwork, casadi_int* iwork) { // NOLINT(whitespace/line_length)\n"
  "  casadi_int nrow_x, ncol_x, ncol_y, i, jj, kk, nnz;\n"
  "  const casadi_int *colind_x, *row_x, *colind_y, *row_y;\n"
  "  casadi_int *mask, *next;\n"
  "  T1 res = 0;\n"
  "  // Get sparsities\n"
  "  nrow_x = sp_x[0]; ncol_x = sp_x[1];\n"
  "  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;\n"
  "  ncol_y = sp_y[1];\n"
  "  colind_y = sp_y+2; row_y = sp_y + 2 + ncol_y+1;\n"
  "  // Implementation inspired on Scipy's sparsetools/csr.h\n"
  "  // method that uses O(n) temp storage\n"
  "  mask = iwork + ncol_y+1;\n"
  "  // Pass 1\n"
  "  for (i=0; i<nrow_x; ++i) mask[i] = -1;\n"
  "  iwork[0] = 0;\n"
  "  nnz = 0;\n"
  "  for (i=0; i<ncol_y; ++i) {\n"
  "    casadi_int next_nnz;\n"
  "    casadi_int row_nnz = 0;\n"
  "    for (jj=colind_y[i]; jj < colind_y[i+1]; jj++) {\n"
  "      casadi_int j = row_y[jj];\n"
  "      for (kk=colind_x[j]; kk < colind_x[j+1]; kk++) {\n"
  "        casadi_int k = row_x[kk];\n"
  "        if (mask[k] != i) {\n"
  "          mask[k] = i;\n"
  "          row_nnz++;\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "    next_nnz = nnz + row_nnz;\n"
  "    nnz = next_nnz;\n"
  "    iwork[i+1] = nnz;\n"
  "  }\n"
  "  // Pass 2\n"
  "  next = iwork + ncol_y+1;\n"
  "  for (i=0; i<nrow_x; ++i) next[i] = -1;\n"
  "  T1* sums = dwork;\n"
  "  for (i=0; i<nrow_x; ++i) sums[i] = 0;\n"
  "  nnz = 0;\n"
  "  iwork[0] = 0;\n"
  "  for (i=0; i<ncol_y; ++i) {\n"
  "    casadi_int head, length, jj_start, jj_end;\n"
  "    head   = -2;\n"
  "    length =  0;\n"
  "    jj_start = colind_y[i];\n"
  "    jj_end   = colind_y[i+1];\n"
  "    for (jj=jj_start; jj<jj_end; ++jj) {\n"
  "      casadi_int j, kk_start, kk_end;\n"
  "      T1 v;\n"
  "      j = row_y[jj];\n"
  "      v = y[jj];\n"
  "      kk_start = colind_x[j];\n"
  "      kk_end   = colind_x[j+1];\n"
  "      for (kk = kk_start; kk<kk_end; ++kk) {\n"
  "        casadi_int k = row_x[kk];\n"
  "        sums[k] += v*x[kk];\n"
  "        if (next[k] == -1) {\n"
  "          next[k] = head;\n"
  "          head  = k;\n"
  "          length++;\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "    for (jj=0; jj<length; ++jj) {\n"
  "      casadi_int temp;\n"
  "      if (!is_zero(sums[head])) {\n"
  "        T1 a = fabs(sums[head]);\n"
  "        res = fmax(res, a);\n"
  "        nnz++;\n"
  "      }\n"
  "      temp = head;\n"
  "      head = next[head];\n"
  "      next[temp] = -1; //clear arrays\n"
  "      sums[temp] =  0;\n"
  "    }\n"
  "    iwork[i+1] = nnz;\n"
  "  }\n"
  "  return res;\n"
  "}\n";

const char* casadi_polyval_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"polyval\"\n"
  "template<typename T1>\n"
  "T1 casadi_polyval(const T1* p, casadi_int n, T1 x) {\n"
  "  casadi_int i;\n"
  "  T1 r=p[0];\n"
  "  for (i=1; i<=n; ++i) {\n"
  "    r = r*x + p[i];\n"
  "  }\n"
  "  return r;\n"
  "}\n";

const char* casadi_project_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"project\"\n"
  "template<typename T1>\n"
  "void casadi_project(const T1* x, const casadi_int* sp_x, T1* y, const casadi_int* sp_y, T1* w) {\n"
  "  // x and y should be distinct\n"
  "  casadi_int ncol_x, ncol_y, i, el;\n"
  "  const casadi_int *colind_x, *row_x, *colind_y, *row_y;\n"
  "  ncol_x = sp_x[1];\n"
  "  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;\n"
  "  ncol_y = sp_y[1];\n"
  "  colind_y = sp_y+2; row_y = sp_y + 2 + ncol_y+1;\n"
  "  // Loop over columns of x and y\n"
  "  for (i=0; i<ncol_x; ++i) {\n"
  "    // Zero out requested entries in y\n"
  "    for (el=colind_y[i]; el<colind_y[i+1]; ++el) w[row_y[el]] = 0;\n"
  "    // Set x entries\n"
  "    for (el=colind_x[i]; el<colind_x[i+1]; ++el) w[row_x[el]] = x[el];\n"
  "    // Retrieve requested entries in y\n"
  "    for (el=colind_y[i]; el<colind_y[i+1]; ++el) y[el] = w[row_y[el]];\n"
  "  }\n"
  "}\n";

const char* casadi_tri_project_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"tri_project\"\n"
  "template<typename T1>\n"
  "void casadi_tri_project(const T1* x, const casadi_int* sp_x, T1* y, casadi_int lower) {\n"
  "  casadi_int ncol_x, j, k;\n"
  "  const casadi_int *colind_x, *row_x;\n"
  "  ncol_x = sp_x[1];\n"
  "  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;\n"
  "  for (j=0; j<ncol_x; ++j) {\n"
  "    for (k=colind_x[j]; k<colind_x[j+1]; ++k) {\n"
  "      if (lower) {\n"
  "        if (row_x[k]>=j) *y++ = x ? x[k] : 0;\n"
  "      } else {\n"
  "        if (row_x[k]<=j) *y++ = x ? x[k] : 0;\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_rank1_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"rank1\"\n"
  "template<typename T1>\n"
  "void casadi_rank1(T1* A, const casadi_int* sp_A, T1 alpha, const T1* x, const T1* y) {\n"
  "  casadi_int ncol_A, cc, rr, el;\n"
  "  const casadi_int *colind_A, *row_A;\n"
  "  // Get sparsities\n"
  "  ncol_A = sp_A[1];\n"
  "  colind_A = sp_A+2; row_A = sp_A + 2 + ncol_A+1;\n"
  "  // Loop over the columns of A\n"
  "  for (cc=0; cc<ncol_A; ++cc) {\n"
  "    // Loop over the nonzeros of A\n"
  "    for (el=colind_A[cc]; el<colind_A[cc+1]; ++el) {\n"
  "      // Get row\n"
  "      rr = row_A[el];\n"
  "      // Add the multiple\n"
  "      A[el] += alpha*x[rr]*y[cc];\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_scal_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"scal\"\n"
  "template<typename T1>\n"
  "void casadi_scal(casadi_int n, T1 alpha, T1* x) {\n"
  "  casadi_int i;\n"
  "  if (!x) return;\n"
  "  for (i=0; i<n; ++i) *x++ *= alpha;\n"
  "}\n";

const char* casadi_sparsify_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"sparsify\"\n"
  "template<typename T1, typename T2>\n"
  "void casadi_sparsify(const T1* x, T2* y, const casadi_int* sp_y, casadi_int tr) {\n"
  "  casadi_int nrow_y, ncol_y, i, el;\n"
  "  const casadi_int *colind_y, *row_y;\n"
  "  nrow_y = sp_y[0];\n"
  "  ncol_y = sp_y[1];\n"
  "  colind_y = sp_y+2; row_y = sp_y+ncol_y+3;\n"
  "  if (tr) {\n"
  "    for (i=0; i<ncol_y; ++i) {\n"
  "      for (el=colind_y[i]; el!=colind_y[i+1]; ++el) {\n"
  "        *y++ = CASADI_CAST(T2, x[i + row_y[el]*ncol_y]);\n"
  "      }\n"
  "    }\n"
  "  } else {\n"
  "    for (i=0; i<ncol_y; ++i) {\n"
  "      for (el=colind_y[i]; el!=colind_y[i+1]; ++el) {\n"
  "        *y++ = CASADI_CAST(T2, x[row_y[el]]);\n"
  "      }\n"
  "      x += nrow_y;\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_sum_viol_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"sum_viol\"\n"
  "template<typename T1>\n"
  "T1 casadi_sum_viol(casadi_int n, const T1* x, const T1* lb, const T1* ub) {\n"
  "  T1 r;\n"
  "  casadi_int i;\n"
  "  const T1 zero = 0;\n"
  "  r = 0;\n"
  "  for (i=0; i<n; ++i) {\n"
  "    T1 x_i, lb_i, ub_i;\n"
  "    x_i = x ? *x++ : zero;\n"
  "    lb_i = lb ? *lb++ : zero;\n"
  "    ub_i = ub ? *ub++ : zero;\n"
  "    r += fmax(x_i-ub_i, zero);\n"
  "    r += fmax(lb_i-x_i, zero);\n"
  "  }\n"
  "  return r;\n"
  "}\n";

const char* casadi_swap_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"swap\"\n"
  "template<typename T1>\n"
  "void casadi_swap(casadi_int n, T1* x, casadi_int inc_x, T1* y, casadi_int inc_y) {\n"
  "  T1 t;\n"
  "  casadi_int i;\n"
  "  for (i=0; i<n; ++i) {\n"
  "    t = *x;\n"
  "    *x = *y;\n"
  "    *y = t;\n"
  "    x += inc_x;\n"
  "    y += inc_y;\n"
  "  }\n"
  "}\n";

const char* casadi_trans_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"trans\"\n"
  "template<typename T1>\n"
  "void casadi_trans(const T1* x, const casadi_int* sp_x, T1* y,\n"
  "    const casadi_int* sp_y, casadi_int* tmp) {\n"
  "  casadi_int ncol_x, nnz_x, ncol_y, k;\n"
  "  const casadi_int* row_x, *colind_y;\n"
  "  ncol_x = sp_x[1];\n"
  "  nnz_x = sp_x[2 + ncol_x];\n"
  "  row_x = sp_x + 2 + ncol_x+1;\n"
  "  ncol_y = sp_y[1];\n"
  "  colind_y = sp_y+2;\n"
  "  for (k=0; k<ncol_y; ++k) tmp[k] = colind_y[k];\n"
  "  for (k=0; k<nnz_x; ++k) {\n"
  "    y[tmp[row_x[k]]++] = x[k];\n"
  "  }\n"
  "}\n";

const char* casadi_finite_diff_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"finite_diff_mem\"\n"
  "template<typename T1>\n"
  "struct casadi_finite_diff_mem {\n"
  "  // Input precision\n"
  "  T1 reltol;\n"
  "  // Output precision\n"
  "  T1 abstol;\n"
  "  // Smoothness parameter\n"
  "  // Smaller epsilon: More discontinuity rejecting\n"
  "  // Larger epsilon: More accurate (higher order) if smooth\n"
  "  T1 smoothing;\n"
  "};\n"
  "// C-REPLACE \"casadi_finite_diff_mem<T1>\" \"struct casadi_finite_diff_mem\"\n"
  "// C-REPLACE \"std::numeric_limits<T1>::quiet_NaN()\" \"NAN\"\n"
  "// C-REPLACE \"fmax\" \"casadi_fmax\"\n"
  "// SYMBOL \"forward_diff\"\n"
  "template<typename T1>\n"
  "T1 casadi_forward_diff(T1** yk, T1* y0, T1* J,\n"
  "                       T1 h, casadi_int n_y, const casadi_finite_diff_mem<T1>* m) {\n"
  "  casadi_int i;\n"
  "  for (i=0; i<n_y; ++i) {\n"
  "    J[i] = (yk[0][i]-y0[i])/h;\n"
  "  }\n"
  "  return -1;\n"
  "}\n"
  "// SYMBOL \"central_diff\"\n"
  "template<typename T1>\n"
  "T1 casadi_central_diff(T1** yk, T1* y0, T1* J,\n"
  "                       T1 h, casadi_int n_y, const casadi_finite_diff_mem<T1>* m) {\n"
  "  // Return value\n"
  "  T1 u;\n"
  "  // Stencil\n"
  "  T1 yf, yc, yb;\n"
  "  // Local variables\n"
  "  T1 err_trunc, err_round;\n"
  "  casadi_int i;\n"
  "  // Set u and stencils to zero (also supresses warnings)\n"
  "  yf = yc = yb = u = 0;\n"
  "  for (i=0; i<n_y; ++i) {\n"
  "    // Copy to local variables, return -1 if invalid entry\n"
  "    if (!isfinite((yf=yk[1][i])) || !isfinite((yc=y0[i])) || !isfinite((yb=yk[0][i]))) {\n"
  "      J[i] = std::numeric_limits<T1>::quiet_NaN();\n"
  "      u = -1;\n"
  "      continue;\n"
  "    }\n"
  "    // Central difference approximation\n"
  "    J[i] = (yf - yb)/(2*h);\n"
  "    // Truncation error\n"
  "    err_trunc = yf - 2*yc + yb;\n"
  "    // Roundoff error\n"
  "    err_round = m->reltol/h*fmax(fabs(yf-yc), fabs(yc-yb)) + m->abstol;\n"
  "    // Update error estimate\n"
  "    if (u>=0) u = fmax(u, fabs(err_trunc/err_round));\n"
  "  }\n"
  "  return u;\n"
  "}\n"
  "// SYMBOL \"smoothing_diff\"\n"
  "template<typename T1>\n"
  "T1 casadi_smoothing_diff(T1** yk, T1* y0, T1* J,\n"
  "                         T1 h, casadi_int n_y, const casadi_finite_diff_mem<T1>* m) {\n"
  "  // Return value\n"
  "  T1 u;\n"
  "  // Stencil\n"
  "  T1 yb, yc, yf;\n"
  "  // Local variables\n"
  "  T1 Jk, wk, sw, ui, err_trunc, err_round, sm;\n"
  "  casadi_int i, k;\n"
  "  // Set u and stencils to zero (also supresses warnings)\n"
  "  yf = yc = yb = u = 0;\n"
  "  for (i=0; i<n_y; ++i) {\n"
  "    // Reset derivative estimate, sum of weights, error estimate\n"
  "    J[i] = sw = ui = 0;\n"
  "    // For backward shifted, central and forward shifted\n"
  "    for (k=0; k<3; ++k) {\n"
  "      // Calculate shifted finite difference approximation\n"
  "      if (k==0) {\n"
  "        // Backward shifted\n"
  "        // 7.10 in Conte & Carl de Boor: Elementary Numerical Analysis (1972)\n"
  "        // and 25.3.4 in Abramowitz and Stegun, Handbook of Mathematical Functions (1964)\n"
  "        if (!isfinite((yc=yk[0][i]))) continue;\n"
  "        if (!isfinite((yb=yk[1][i]))) continue;\n"
  "        yf = y0[i];\n"
  "        Jk = 3*yf - 4*yc + yb;\n"
  "        wk = 1;\n"
  "      } else if (k==1) {\n"
  "        // Central\n"
  "        // We give this the \"nominal weight\" 4 since if all weights are equal,\n"
  "        // this would amount to a five point formula for the derivative\n"
  "        // (yb2 - 8*yb + 8*yf - y_f2)/(12*h)\n"
  "        // cf. 25.3.6 in Abramowitz and Stegun, Handbook of Mathematical Functions (1964)\n"
  "        if (!isfinite((yf=yk[2][i]))) continue;\n"
  "        if (!isfinite((yb=yc))) continue;\n"
  "        yc = y0[i];\n"
  "        Jk = yf-yb;\n"
  "        wk = 4;\n"
  "      } else {\n"
  "        // Forward shifted\n"
  "        if (!isfinite((yc=yf))) continue;\n"
  "        if (!isfinite((yf=yk[3][i]))) continue;\n"
  "        yb = y0[i];\n"
  "        Jk = -3*yb + 4*yc - yf;\n"
  "        wk = 1;\n"
  "      }\n"
  "      // Truncation error\n"
  "      err_trunc = yf - 2*yc + yb;\n"
  "      // Roundoff error\n"
  "      err_round = m->reltol/h*fmax(fabs(yf-yc), fabs(yc-yb)) + m->abstol;\n"
  "      // We use the second order derivative as a smoothness measure\n"
  "      sm = err_trunc/(h*h);\n"
  "      // Modify the weight according to smoothness\n"
  "      wk /= sm*sm + m->smoothing;\n"
  "      sw += wk;\n"
  "      // Added weighted contribution to weight and error\n"
  "      J[i] += wk * Jk;\n"
  "      ui += wk * fabs(err_trunc/err_round);\n"
  "    }\n"
  "    // If sw is 0, no stencil worked\n"
  "    if (sw==0) {\n"
  "      // Set component to 0, return -1\n"
  "      J[i] = std::numeric_limits<T1>::quiet_NaN();\n"
  "      u = -1;\n"
  "    } else {\n"
  "      // Finalize estimate using the sum of weights and the step length\n"
  "      J[i] /= 2*h*sw;\n"
  "      if (u>=0) u = fmax(u, ui/sw);\n"
  "    }\n"
  "  }\n"
  "  return u;\n"
  "}\n";

const char* casadi_ldl_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"ldl\"\n"
  "// Calculate the nonzeros of the transposed L factor (strictly lower entries only)\n"
  "// as well as D for an LDL^T factorization\n"
  "// len[w] >= n\n"
  "template<typename T1>\n"
  "void casadi_ldl(const casadi_int* sp_a, const T1* a,\n"
  "                const casadi_int* sp_lt, T1* lt, T1* d, const casadi_int* p, T1* w) {\n"
  "  const casadi_int *lt_colind, *lt_row, *a_colind, *a_row;\n"
  "  casadi_int n, r, c, c1, k, k2;\n"
  "  // Extract sparsities\n"
  "  n=sp_lt[1];\n"
  "  lt_colind=sp_lt+2; lt_row=sp_lt+2+n+1;\n"
  "  a_colind=sp_a+2; a_row=sp_a+2+n+1;\n"
  "  // Clear w\n"
  "  for (r=0; r<n; ++r) w[r] = 0;\n"
  "  // Sparse copy of A to L and D\n"
  "  for (c=0; c<n; ++c) {\n"
  "    c1 = p[c];\n"
  "    for (k=a_colind[c1]; k<a_colind[c1+1]; ++k) w[a_row[k]] = a[k];\n"
  "    for (k=lt_colind[c]; k<lt_colind[c+1]; ++k) lt[k] = w[p[lt_row[k]]];\n"
  "    d[c] = w[p[c]];\n"
  "    for (k=a_colind[c1]; k<a_colind[c1+1]; ++k) w[a_row[k]] = 0;\n"
  "  }\n"
  "  // Loop over columns of L\n"
  "  for (c=0; c<n; ++c) {\n"
  "    for (k=lt_colind[c]; k<lt_colind[c+1]; ++k) {\n"
  "      r = lt_row[k];\n"
  "      // Calculate l(r,c) with r<c\n"
  "      for (k2=lt_colind[r]; k2<lt_colind[r+1]; ++k2) {\n"
  "        lt[k] -= lt[k2] * w[lt_row[k2]];\n"
  "      }\n"
  "      w[r] = lt[k];\n"
  "      lt[k] /= d[r];\n"
  "      // Update d(c)\n"
  "      d[c] -= w[r]*lt[k];\n"
  "    }\n"
  "    // Clear w\n"
  "    for (k=lt_colind[c]; k<lt_colind[c+1]; ++k) w[lt_row[k]] = 0;\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"ldl_trs\"\n"
  "// Solve for (I+R) with R an optionally transposed strictly upper triangular matrix.\n"
  "template<typename T1>\n"
  "void casadi_ldl_trs(const casadi_int* sp_r, const T1* nz_r, T1* x, casadi_int tr) {\n"
  "  casadi_int ncol, c, k;\n"
  "  const casadi_int *colind, *row;\n"
  "  // Extract sparsity\n"
  "  ncol=sp_r[1];\n"
  "  colind=sp_r+2; row=sp_r+2+ncol+1;\n"
  "  if (tr) {\n"
  "    // Forward substitution\n"
  "    for (c=0; c<ncol; ++c) {\n"
  "      for (k=colind[c]; k<colind[c+1]; ++k) {\n"
  "        x[c] -= nz_r[k]*x[row[k]];\n"
  "      }\n"
  "    }\n"
  "  } else {\n"
  "    // Backward substitution\n"
  "    for (c=ncol-1; c>=0; --c) {\n"
  "      for (k=colind[c+1]-1; k>=colind[c]; --k) {\n"
  "        x[row[k]] -= nz_r[k]*x[c];\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"ldl_solve\"\n"
  "// Linear solve using an LDL^T factorized linear system\n"
  "template<typename T1>\n"
  "void casadi_ldl_solve(T1* x, casadi_int nrhs, const casadi_int* sp_lt, const T1* lt,\n"
  "                      const T1* d, const casadi_int* p, T1* w) {\n"
  "  casadi_int i, k;\n"
  "  casadi_int n = sp_lt[1];\n"
  "  for (k=0; k<nrhs; ++k) {\n"
  "    // P' L D L' P x = b <=> x = P' L' \\ D \\ L \\ P b\n"
  "    // Multiply by P\n"
  "    for (i=0; i<n; ++i) w[i] = x[p[i]];\n"
  "    //  Solve for L\n"
  "    casadi_ldl_trs(sp_lt, lt, w, 1);\n"
  "    // Divide by D\n"
  "    for (i=0; i<n; ++i) w[i] /= d[i];\n"
  "    // Solve for L'\n"
  "    casadi_ldl_trs(sp_lt, lt, w, 0);\n"
  "    // Multiply by P'\n"
  "    for (i=0; i<n; ++i) x[p[i]] = w[i];\n"
  "    // Next rhs\n"
  "    x += n;\n"
  "  }\n"
  "}\n";

const char* casadi_qr_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"house\"\n"
  "// Householder reflection\n"
  "// Ref: Chapter 5, Direct Methods for Sparse Linear Systems by Tim Davis\n"
  "template<typename T1>\n"
  "T1 casadi_house(T1* v, T1* beta, casadi_int nv) {\n"
  "  // Local variable\n"
  "  casadi_int i;\n"
  "  T1 v0, sigma, s, sigma_is_zero, v0_nonpos;\n"
  "  // Calculate norm\n"
  "  v0 = v[0]; // Save v0 (overwritten below)\n"
  "  sigma=0;\n"
  "  for (i=1; i<nv; ++i) sigma += v[i]*v[i];\n"
  "  s = sqrt(v0*v0 + sigma); // s = norm(v)\n"
  "  // Calculate consistently with symbolic datatypes (SXElem)\n"
  "  sigma_is_zero = sigma==0;\n"
  "  v0_nonpos = v0<=0;\n"
  "  // C-REPLACE \"if_else\" \"casadi_if_else\"\n"
  "  v[0] = if_else(sigma_is_zero, 1,\n"
  "                 if_else(v0_nonpos, v0-s, -sigma/(v0+s))); // NOLINT\n"
  "  *beta = if_else(sigma_is_zero, 2*v0_nonpos, -1/(s*v[0])); // NOLINT\n"
  "  return s;\n"
  "}\n"
  "// SYMBOL \"qr\"\n"
  "// Numeric QR factorization\n"
  "// Ref: Chapter 5, Direct Methods for Sparse Linear Systems by Tim Davis\n"
  "// len[x] = nrow\n"
  "// sp_v = [nrow, ncol, 0, 0, ...] len[3 + ncol + nnz_v]\n"
  "// len[v] nnz_v\n"
  "// sp_r = [nrow, ncol, 0, 0, ...] len[3 + ncol + nnz_r]\n"
  "// len[r] nnz_r\n"
  "// len[beta] ncol\n"
  "template<typename T1>\n"
  "void casadi_qr(const casadi_int* sp_a, const T1* nz_a, T1* x,\n"
  "               const casadi_int* sp_v, T1* nz_v, const casadi_int* sp_r, T1* nz_r, T1* beta,\n"
  "               const casadi_int* prinv, const casadi_int* pc) {\n"
  "   // Local variables\n"
  "   casadi_int ncol, nrow, r, c, k, k1;\n"
  "   T1 alpha;\n"
  "   const casadi_int *a_colind, *a_row, *v_colind, *v_row, *r_colind, *r_row;\n"
  "   // Extract sparsities\n"
  "   ncol = sp_a[1];\n"
  "   a_colind=sp_a+2; a_row=sp_a+2+ncol+1;\n"
  "   nrow = sp_v[0];\n"
  "   v_colind=sp_v+2; v_row=sp_v+2+ncol+1;\n"
  "   r_colind=sp_r+2; r_row=sp_r+2+ncol+1;\n"
  "   // Clear work vector\n"
  "   for (r=0; r<nrow; ++r) x[r] = 0;\n"
  "   // Loop over columns of R, A and V\n"
  "   for (c=0; c<ncol; ++c) {\n"
  "     // Copy (permuted) column of A to x\n"
  "     for (k=a_colind[pc[c]]; k<a_colind[pc[c]+1]; ++k) x[prinv[a_row[k]]] = nz_a[k];\n"
  "     // Use the equality R = (I-betan*vn*vn')*...*(I-beta1*v1*v1')*A to get\n"
  "     // strictly upper triangular entries of R\n"
  "     for (k=r_colind[c]; k<r_colind[c+1] && (r=r_row[k])<c; ++k) {\n"
  "       // Calculate scalar factor alpha = beta(r)*dot(v(:,r), x)\n"
  "       alpha = 0;\n"
  "       for (k1=v_colind[r]; k1<v_colind[r+1]; ++k1) alpha += nz_v[k1]*x[v_row[k1]];\n"
  "       alpha *= beta[r];\n"
  "       // x -= alpha*v(:,r)\n"
  "       for (k1=v_colind[r]; k1<v_colind[r+1]; ++k1) x[v_row[k1]] -= alpha*nz_v[k1];\n"
  "       // Get r entry\n"
  "       *nz_r++ = x[r];\n"
  "       // Strictly upper triangular entries in x no longer needed\n"
  "       x[r] = 0;\n"
  "     }\n"
  "     // Get V column\n"
  "     for (k=v_colind[c]; k<v_colind[c+1]; ++k) {\n"
  "       nz_v[k] = x[v_row[k]];\n"
  "       // Lower triangular entries of x no longer needed\n"
  "       x[v_row[k]] = 0;\n"
  "     }\n"
  "     // Get diagonal entry of R, normalize V column\n"
  "     *nz_r++ = casadi_house(nz_v + v_colind[c], beta + c, v_colind[c+1] - v_colind[c]);\n"
  "   }\n"
  " }\n"
  "// SYMBOL \"qr_mv\"\n"
  "// Multiply QR Q matrix from the right with a vector, with Q represented\n"
  "// by the Householder vectors V and beta\n"
  "// x = Q*x or x = Q'*x\n"
  "// with Q = (I-beta(1)*v(:,1)*v(:,1)')*...*(I-beta(n)*v(:,n)*v(:,n)')\n"
  "// len[x] >= nrow_ext\n"
  "template<typename T1>\n"
  "void casadi_qr_mv(const casadi_int* sp_v, const T1* v, const T1* beta, T1* x,\n"
  "                  casadi_int tr) {\n"
  "  // Local variables\n"
  "  casadi_int ncol, c, c1, k;\n"
  "  T1 alpha;\n"
  "  const casadi_int *colind, *row;\n"
  "  // Extract sparsity\n"
  "  ncol=sp_v[1];\n"
  "  colind=sp_v+2; row=sp_v+2+ncol+1;\n"
  "  // Loop over vectors\n"
  "  for (c1=0; c1<ncol; ++c1) {\n"
  "    // Forward order for transpose, otherwise backwards\n"
  "    c = tr ? c1 : ncol-1-c1;\n"
  "    // Calculate scalar factor alpha = beta(c)*dot(v(:,c), x)\n"
  "    alpha=0;\n"
  "    for (k=colind[c]; k<colind[c+1]; ++k) alpha += v[k]*x[row[k]];\n"
  "    alpha *= beta[c];\n"
  "    // x -= alpha*v(:,c)\n"
  "    for (k=colind[c]; k<colind[c+1]; ++k) x[row[k]] -= alpha*v[k];\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qr_trs\"\n"
  "// Solve for an (optionally transposed) upper triangular matrix R\n"
  "template<typename T1>\n"
  "void casadi_qr_trs(const casadi_int* sp_r, const T1* nz_r, T1* x, casadi_int tr) {\n"
  "  // Local variables\n"
  "  casadi_int ncol, r, c, k;\n"
  "  const casadi_int *colind, *row;\n"
  "  // Extract sparsity\n"
  "  ncol=sp_r[1];\n"
  "  colind=sp_r+2; row=sp_r+2+ncol+1;\n"
  "  if (tr) {\n"
  "    // Forward substitution\n"
  "    for (c=0; c<ncol; ++c) {\n"
  "      for (k=colind[c]; k<colind[c+1]; ++k) {\n"
  "        r = row[k];\n"
  "        if (r==c) {\n"
  "          x[c] /= nz_r[k];\n"
  "        } else {\n"
  "          x[c] -= nz_r[k]*x[r];\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  } else {\n"
  "    // Backward substitution\n"
  "    for (c=ncol-1; c>=0; --c) {\n"
  "      for (k=colind[c+1]-1; k>=colind[c]; --k) {\n"
  "        r=row[k];\n"
  "        if (r==c) {\n"
  "          x[r] /= nz_r[k];\n"
  "        } else {\n"
  "          x[r] -= nz_r[k]*x[c];\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qr_solve\"\n"
  "// Solve a factorized linear system\n"
  "// len[w] >= max(ncol, nrow_ext)\n"
  "template<typename T1>\n"
  "void casadi_qr_solve(T1* x, casadi_int nrhs, casadi_int tr,\n"
  "                     const casadi_int* sp_v, const T1* v, const casadi_int* sp_r, const T1* r,\n"
  "                     const T1* beta, const casadi_int* prinv, const casadi_int* pc, T1* w) {\n"
  "  casadi_int k, c, nrow_ext, ncol;\n"
  "  nrow_ext = sp_v[0]; ncol = sp_v[1];\n"
  "  for (k=0; k<nrhs; ++k) {\n"
  "    if (tr) {\n"
  "      // (PR' Q R PC)' x = PC' R' Q' PR x = b <-> x = PR' Q R' \\ PC b\n"
  "      // Multiply by PC\n"
  "      for (c=0; c<ncol; ++c) w[c] = x[pc[c]];\n"
  "      //  Solve for R'\n"
  "      casadi_qr_trs(sp_r, r, w, 1);\n"
  "      // Multiply by Q\n"
  "      casadi_qr_mv(sp_v, v, beta, w, 0);\n"
  "      // Multiply by PR'\n"
  "      for (c=0; c<ncol; ++c) x[c] = w[prinv[c]];\n"
  "    } else {\n"
  "      //PR' Q R PC x = b <-> x = PC' R \\ Q' PR b\n"
  "      // Multiply with PR\n"
  "      for (c=0; c<nrow_ext; ++c) w[c] = 0;\n"
  "      for (c=0; c<ncol; ++c) w[prinv[c]] = x[c];\n"
  "      // Multiply with Q'\n"
  "      casadi_qr_mv(sp_v, v, beta, w, 1);\n"
  "      //  Solve for R\n"
  "      casadi_qr_trs(sp_r, r, w, 0);\n"
  "      // Multiply with PC'\n"
  "      for (c=0; c<ncol; ++c) x[pc[c]] = w[c];\n"
  "    }\n"
  "    x += ncol;\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qr_singular\"\n"
  "// Check if QR factorization corresponds to a singular matrix\n"
  "template<typename T1>\n"
  "casadi_int casadi_qr_singular(T1* rmin, casadi_int* irmin, const T1* nz_r,\n"
  "                             const casadi_int* sp_r, const casadi_int* pc, T1 eps) {\n"
  "  // Local variables\n"
  "  T1 rd, rd_min;\n"
  "  casadi_int ncol, c, nullity;\n"
  "  const casadi_int* r_colind;\n"
  "  // Nullity\n"
  "  nullity = 0;\n"
  "  // Extract sparsity\n"
  "  ncol = sp_r[1];\n"
  "  r_colind = sp_r + 2;\n"
  "  // Find the smallest diagonal entry\n"
  "  for (c=0; c<ncol; ++c) {\n"
  "    rd = fabs(nz_r[r_colind[c+1]-1]);\n"
  "    // Increase nullity if smaller than eps\n"
  "    if (rd<eps) nullity++;\n"
  "    // Check if smallest so far\n"
  "    if (c==0 || rd < rd_min) {\n"
  "      rd_min = rd;\n"
  "      if (rmin) *rmin = rd;\n"
  "      if (irmin) *irmin = pc[c];\n"
  "    }\n"
  "  }\n"
  "  // Return number of zero-ish eigenvalues\n"
  "  return nullity;\n"
  "}\n"
  "// SYMBOL \"qr_colcomb\"\n"
  "// Get a vector v such that A*v = 0 and |v| == 1\n"
  "template<typename T1>\n"
  "void casadi_qr_colcomb(T1* v, const T1* nz_r, const casadi_int* sp_r,\n"
  "                       const casadi_int* pc, T1 eps, casadi_int ind) {\n"
  "  // Local variables\n"
  "  casadi_int ncol, r, c, k;\n"
  "  const casadi_int *r_colind, *r_row;\n"
  "  // Extract sparsity\n"
  "  ncol = sp_r[1];\n"
  "  r_colind = sp_r + 2;\n"
  "  r_row = r_colind + ncol + 1;\n"
  "  // Find the ind-th diagonal which is smaller than eps, overwrite ind with c\n"
  "  for (c=0; c<ncol; ++c) {\n"
  "    if (fabs(nz_r[r_colind[c+1]-1])<eps && 0==ind--) {\n"
  "      ind = c;\n"
  "      break;\n"
  "    }\n"
  "  }\n"
  "  // Reset w\n"
  "  casadi_clear(v, ncol);\n"
  "  v[pc[ind]] = 1.;\n"
  "  // Copy ind-th column to v\n"
  "  for (k=r_colind[ind]; k<r_colind[ind+1]-1; ++k) {\n"
  "    v[pc[r_row[k]]] = -nz_r[k];\n"
  "  }\n"
  "  // Backward substitution\n"
  "  for (c=ind-1; c>=0; --c) {\n"
  "    for (k=r_colind[c+1]-1; k>=r_colind[c]; --k) {\n"
  "      r=r_row[k];\n"
  "      if (r==c) {\n"
  "        if (fabs(nz_r[k])<eps) {\n"
  "          v[pc[r]] = 0;\n"
  "        } else {\n"
  "          v[pc[r]] /= nz_r[k];\n"
  "        }\n"
  "      } else {\n"
  "        v[pc[r]] -= nz_r[k]*v[pc[c]];\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  // Normalize v\n"
  "  casadi_scal(ncol, 1./sqrt(casadi_dot(ncol, v, v)), v);\n"
  "}\n";

const char* casadi_qp_str =
  "// NOLINT(legal/copyright)\n"
  "// C-REPLACE \"fmin\" \"casadi_fmin\"\n"
  "// C-REPLACE \"fmax\" \"casadi_fmax\"\n"
  "// C-REPLACE \"std::numeric_limits<T1>::min()\" \"casadi_real_min\"\n"
  "// C-REPLACE \"std::numeric_limits<T1>::infinity()\" \"casadi_inf\"\n"
  "// C-REPLACE \"static_cast<int>\" \"(int) \"\n"
  "// SYMBOL \"qp_prob\"\n"
  "template<typename T1>\n"
  "struct casadi_qp_prob {\n"
  "  // Sparsity patterns\n"
  "  const casadi_int *sp_a, *sp_h, *sp_at, *sp_kkt;\n"
  "  // Symbolic QR factorization\n"
  "  const casadi_int *prinv, *pc, *sp_v, *sp_r;\n"
  "  // Dimensions\n"
  "  casadi_int nx, na, nz;\n"
  "  // Smallest nonzero number\n"
  "  T1 dmin;\n"
  "  // Infinity\n"
  "  T1 inf;\n"
  "  // Smallest multiplier treated as inactive for the initial active set\n"
  "  T1 min_lam;\n"
  "  // Maximum number of iterations\n"
  "  casadi_int max_iter;\n"
  "  // Primal and dual error tolerance\n"
  "  T1 constr_viol_tol, dual_inf_tol;\n"
  "};\n"
  "// C-REPLACE \"casadi_qp_prob<T1>\" \"struct casadi_qp_prob\"\n"
  "// SYMBOL \"qp_setup\"\n"
  "template<typename T1>\n"
  "void casadi_qp_setup(casadi_qp_prob<T1>* p) {\n"
  "  p->na = p->sp_a[0];\n"
  "  p->nx = p->sp_a[1];\n"
  "  p->nz = p->nx + p->na;\n"
  "  p->dmin = std::numeric_limits<T1>::min();\n"
  "  p->inf = std::numeric_limits<T1>::infinity();\n"
  "  p->min_lam = 0;\n"
  "  p->max_iter = 1000;\n"
  "  p->constr_viol_tol = 1e-8;\n"
  "  p->dual_inf_tol = 1e-8;\n"
  "}\n"
  "// SYMBOL \"qp_work\"\n"
  "template<typename T1>\n"
  "void casadi_qp_work(const casadi_qp_prob<T1>* p, casadi_int* sz_iw, casadi_int* sz_w) {\n"
  "  // Local variables\n"
  "  casadi_int nnz_a, nnz_kkt, nnz_v, nnz_r;\n"
  "  // Get matrix number of nonzeros\n"
  "  nnz_a = p->sp_a[2+p->sp_a[1]];\n"
  "  nnz_kkt = p->sp_kkt[2+p->sp_kkt[1]];\n"
  "  nnz_v = p->sp_v[2+p->sp_v[1]];\n"
  "  nnz_r = p->sp_r[2+p->sp_r[1]];\n"
  "  // Reset sz_w, sz_iw\n"
  "  *sz_w = *sz_iw = 0;\n"
  "  // Temporary work vectors\n"
  "  *sz_w = casadi_max(*sz_w, p->nz); // casadi_project, tau memory\n"
  "  *sz_iw = casadi_max(*sz_iw, p->nz); // casadi_trans, tau type, allzero\n"
  "  *sz_w = casadi_max(*sz_w, 2*p->nz); // casadi_qr\n"
  "  // Persistent work vectors\n"
  "  *sz_w += nnz_kkt; // kkt\n"
  "  *sz_w += p->nz; // z=[xk,gk]\n"
  "  *sz_w += p->nz; // lbz\n"
  "  *sz_w += p->nz; // ubz\n"
  "  *sz_w += p->nz; // lam\n"
  "  *sz_w += nnz_a; // trans(a)\n"
  "  *sz_w += p->nz; // dz\n"
  "  *sz_w += p->nz; // dlam\n"
  "  *sz_w += p->nx; // infeas\n"
  "  *sz_w += p->nx; // tinfeas\n"
  "  *sz_w += p->nz; // sens\n"
  "  *sz_iw += p->nz; // neverzero\n"
  "  *sz_iw += p->nz; // neverupper\n"
  "  *sz_iw += p->nz; // neverlower\n"
  "  *sz_iw += p->nz; // lincomb\n"
  "  *sz_w += casadi_max(nnz_v+nnz_r, nnz_kkt); // [v,r] or trans(kkt)\n"
  "  *sz_w += p->nz; // beta\n"
  "}\n"
  "// SYMBOL \"qp_flag_t\"\n"
  "typedef enum {\n"
  "  QP_SUCCESS,\n"
  "  QP_MAX_ITER,\n"
  "  QP_NO_SEARCH_DIR,\n"
  "  QP_PRINTING_ERROR\n"
  "} casadi_qp_flag_t;\n"
  "// SYMBOL \"qp_data\"\n"
  "template<typename T1>\n"
  "struct casadi_qp_data {\n"
  "  // Problem structure\n"
  "  const casadi_qp_prob<T1>* prob;\n"
  "  // Solver status\n"
  "  casadi_qp_flag_t status;\n"
  "  // Cost\n"
  "  T1 f;\n"
  "  // QP data\n"
  "  const T1 *nz_a, *nz_h, *g;\n"
  "  // Vectors\n"
  "  T1 *z, *lbz, *ubz, *infeas, *tinfeas, *sens, *lam, *w, *dz, *dlam;\n"
  "  casadi_int *iw, *neverzero, *neverlower, *neverupper, *lincomb;\n"
  "  // Numeric QR factorization\n"
  "  T1 *nz_at, *nz_kkt, *beta, *nz_v, *nz_r;\n"
  "  // Message buffer\n"
  "  const char *msg;\n"
  "  // Message index\n"
  "  casadi_int msg_ind;\n"
  "  // Stepsize\n"
  "  T1 tau;\n"
  "  // Singularity\n"
  "  casadi_int sing;\n"
  "  // Do we already have a search direction?\n"
  "  int has_search_dir;\n"
  "  // Smallest diagonal value for the QR factorization\n"
  "  T1 mina;\n"
  "  casadi_int imina;\n"
  "  // Primal and dual error, corresponding index\n"
  "  T1 pr, du, epr, edu;\n"
  "  casadi_int ipr, idu;\n"
  "  // Pending active-set change\n"
  "  casadi_int index, sign;\n"
  "  // Feasibility restoration active-set change\n"
  "  casadi_int r_index, r_sign;\n"
  "  // Iteration\n"
  "  casadi_int iter;\n"
  "};\n"
  "// C-REPLACE \"casadi_qp_data<T1>\" \"struct casadi_qp_data\"\n"
  "// SYMBOL \"qp_init\"\n"
  "template<typename T1>\n"
  "void casadi_qp_init(casadi_qp_data<T1>* d, casadi_int** iw, T1** w) {\n"
  "  // Local variables\n"
  "  casadi_int nnz_a, nnz_kkt, nnz_v, nnz_r;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Get matrix number of nonzeros\n"
  "  nnz_a = p->sp_a[2+p->sp_a[1]];\n"
  "  nnz_kkt = p->sp_kkt[2+p->sp_kkt[1]];\n"
  "  nnz_v = p->sp_v[2+p->sp_v[1]];\n"
  "  nnz_r = p->sp_r[2+p->sp_r[1]];\n"
  "  d->nz_kkt = *w; *w += nnz_kkt;\n"
  "  d->z = *w; *w += p->nz;\n"
  "  d->lbz = *w; *w += p->nz;\n"
  "  d->ubz = *w; *w += p->nz;\n"
  "  d->lam = *w; *w += p->nz;\n"
  "  d->dz = *w; *w += p->nz;\n"
  "  d->dlam = *w; *w += p->nz;\n"
  "  d->nz_v = *w; *w += casadi_max(nnz_v+nnz_r, nnz_kkt);\n"
  "  d->nz_r = d->nz_v + nnz_v;\n"
  "  d->beta = *w; *w += p->nz;\n"
  "  d->nz_at = *w; *w += nnz_a;\n"
  "  d->infeas = *w; *w += p->nx;\n"
  "  d->tinfeas = *w; *w += p->nx;\n"
  "  d->sens = *w; *w += p->nz;\n"
  "  d->neverzero = *iw; *iw += p->nz;\n"
  "  d->neverupper = *iw; *iw += p->nz;\n"
  "  d->neverlower = *iw; *iw += p->nz;\n"
  "  d->lincomb = *iw; *iw += p->nz;\n"
  "  d->w = *w;\n"
  "  d->iw = *iw;\n"
  "}\n"
  "// SYMBOL \"qp_reset\"\n"
  "template<typename T1>\n"
  "int casadi_qp_reset(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Reset variables corresponding to previous iteration\n"
  "  d->msg = 0;\n"
  "  d->tau = 0.;\n"
  "  d->sing = 0;\n"
  "  // Correct lam if needed, determine permitted signs\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    // Permitted signs for lam\n"
  "    d->neverzero[i] = d->lbz[i] == d->ubz[i];\n"
  "    d->neverupper[i] = d->ubz[i] == p->inf;\n"
  "    d->neverlower[i] = d->lbz[i] == -p->inf;\n"
  "    if (d->neverzero[i] && d->neverupper[i] && d->neverlower[i]) return 1;\n"
  "    // Small enough lambdas are treated as inactive\n"
  "    if (!d->neverzero[i] && fabs(d->lam[i]) < p->min_lam) d->lam[i] = 0.;\n"
  "    // Prevent illegal active sets\n"
  "    if (d->neverzero[i] && d->lam[i] == 0.) {\n"
  "      d->lam[i] = d->neverupper[i]\n"
  "                || d->z[i]-d->lbz[i] <= d->ubz[i]-d->z[i] ? -p->dmin : p->dmin;\n"
  "    } else if (d->neverupper[i] && d->lam[i]>0.) {\n"
  "      d->lam[i] = d->neverzero[i] ? -p->dmin : 0.;\n"
  "    } else if (d->neverlower[i] && d->lam[i]<0.) {\n"
  "      d->lam[i] = d->neverzero[i] ? p->dmin : 0.;\n"
  "    }\n"
  "  }\n"
  "  // Transpose A\n"
  "  casadi_trans(d->nz_a, p->sp_a, d->nz_at, p->sp_at, d->iw);\n"
  "  // No pending active-set change\n"
  "  d->index = -2;\n"
  "  d->sign = 0;\n"
  "  // No restoration index\n"
  "  d->r_index = -2;\n"
  "  d->r_sign = 0;\n"
  "  // Reset iteration counter\n"
  "  d->iter = 0;\n"
  "  return 0;\n"
  "}\n"
  "// SYMBOL \"qp_pr\"\n"
  "template<typename T1>\n"
  "void casadi_qp_pr(casadi_qp_data<T1>* d) {\n"
  "  // Calculate largest constraint violation\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  d->pr = 0;\n"
  "  d->ipr = -1;\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    if (d->z[i] > d->ubz[i]+d->pr) {\n"
  "      d->pr = d->z[i]-d->ubz[i];\n"
  "      d->ipr = i;\n"
  "    } else if (d->z[i] < d->lbz[i]-d->pr) {\n"
  "      d->pr = d->lbz[i]-d->z[i];\n"
  "      d->ipr = i;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_du\"\n"
  "template<typename T1>\n"
  "void casadi_qp_du(casadi_qp_data<T1>* d) {\n"
  "  // Calculate largest constraint violation\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  d->du = 0;\n"
  "  d->idu = -1;\n"
  "  for (i=0; i<p->nx; ++i) {\n"
  "    if (d->infeas[i] > d->du) {\n"
  "      d->du = d->infeas[i];\n"
  "      d->idu = i;\n"
  "    } else if (d->infeas[i] < -d->du) {\n"
  "      d->du = -d->infeas[i];\n"
  "      d->idu = i;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_du_check\"\n"
  "template<typename T1>\n"
  "int casadi_qp_du_check(casadi_qp_data<T1>* d, casadi_int i) {\n"
  "  // Local variables\n"
  "  casadi_int k;\n"
  "  T1 new_du;\n"
  "  const casadi_int *at_colind, *at_row;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // AT sparsity\n"
  "  at_colind = p->sp_at + 2;\n"
  "  at_row = at_colind + p->na + 1;\n"
  "  // Maximum infeasibility from setting from setting lam[i]=0\n"
  "  if (i<p->nx) {\n"
  "    new_du = fabs(d->infeas[i]-d->lam[i]);\n"
  "  } else {\n"
  "    new_du = 0.;\n"
  "    for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {\n"
  "      new_du = fmax(new_du, fabs(d->infeas[at_row[k]]-d->nz_at[k]*d->lam[i]));\n"
  "    }\n"
  "  }\n"
  "  return new_du <= d->du;\n"
  "}\n"
  "// SYMBOL \"qp_du_index\"\n"
  "template<typename T1>\n"
  "void casadi_qp_du_index(casadi_qp_data<T1>* d) {\n"
  "  // Try to improve dual feasibility by removing a constraint\n"
  "  // Local variables\n"
  "  casadi_int i, s;\n"
  "  T1 best_sens;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Find the best lam[i] to make zero\n"
  "  d->index = -1;\n"
  "  best_sens = -1;\n"
  "  for (i = 0; i < p->nz; ++i) {\n"
  "    // Skip if no dual infeasibility sensitivity\n"
  "    if (d->sens[i] == 0.) continue;\n"
  "    // Is the constraint enforced?\n"
  "    if (d->lam[i] == 0) {\n"
  "      // We're enforcing constraints\n"
  "      s = d->sens[i] > 0 ? 1 : -1;\n"
  "      // Make sure that enforcing the constraint is possible\n"
  "      if (s > 0 ? d->neverupper[i] : d->neverlower[i]) continue;\n"
  "    } else {\n"
  "      // We're removing constraints\n"
  "      s = 0;\n"
  "      // Make sure that it's a constraint that can be removed\n"
  "      if (d->neverzero[i]) continue;\n"
  "      // If variable influences du, make sure sign is right\n"
  "      if (d->lam[i] > 0. ? d->sens[i] > 0. : d->sens[i] < 0.) continue;\n"
  "      // Skip if maximum infeasibility increases\n"
  "      if (!casadi_qp_du_check(d, i)) continue;\n"
  "    }\n"
  "    // Check if best so far\n"
  "    if (fabs(d->sens[i]) > best_sens) {\n"
  "      best_sens = fabs(d->sens[i]);\n"
  "      d->index = i;\n"
  "      d->sign = s;\n"
  "    }\n"
  "  }\n"
  "  // Accept, if any\n"
  "  if (d->index >= 0) {\n"
  "    if (d->sign > 0) {\n"
  "      d->msg = \"Enforced ubz to reduce |du|\";\n"
  "    } else if (d->sign < 0) {\n"
  "      d->msg = \"Enforced lbz to reduce |du|\";\n"
  "    } else if (d->lam[d->index] > 0) {\n"
  "      d->msg = \"Dropped ubz to reduce |du|\";\n"
  "    } else {\n"
  "      d->msg = \"Dropped lbz to reduce |du|\";\n"
  "    }\n"
  "    d->msg_ind = d->index;\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_pr_index\"\n"
  "template<typename T1>\n"
  "void casadi_qp_pr_index(casadi_qp_data<T1>* d) {\n"
  "  // Try to improve primal feasibility by adding a constraint\n"
  "  if (d->lam[d->ipr] == 0.) {\n"
  "    // Add the most violating constraint\n"
  "    if (d->z[d->ipr] < d->lbz[d->ipr]) {\n"
  "      d->sign = -1;\n"
  "      d->msg = \"Added lbz to reduce |pr|\";\n"
  "    } else {\n"
  "      d->sign = 1;\n"
  "      d->msg = \"Added ubz to reduce |pr|\";\n"
  "    }\n"
  "    d->msg_ind = d->ipr;\n"
  "    d->index = d->ipr;\n"
  "  } else {\n"
  "    // No improvement possible\n"
  "    d->index = -1;\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_kkt\"\n"
  "template<typename T1>\n"
  "void casadi_qp_kkt(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i, k;\n"
  "  const casadi_int *h_colind, *h_row, *a_colind, *a_row, *at_colind, *at_row,\n"
  "                   *kkt_colind, *kkt_row;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Extract sparsities\n"
  "  a_row = (a_colind = p->sp_a+2) + p->nx + 1;\n"
  "  at_row = (at_colind = p->sp_at+2) + p->na + 1;\n"
  "  h_row = (h_colind = p->sp_h+2) + p->nx + 1;\n"
  "  kkt_row = (kkt_colind = p->sp_kkt+2) + p->nz + 1;\n"
  "  // Reset w to zero\n"
  "  casadi_clear(d->w, p->nz);\n"
  "  // Loop over rows of the (transposed) KKT\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    // Copy row of KKT to w\n"
  "    if (i<p->nx) {\n"
  "      if (d->lam[i]==0) {\n"
  "        for (k=h_colind[i]; k<h_colind[i+1]; ++k) d->w[h_row[k]] = d->nz_h[k];\n"
  "        for (k=a_colind[i]; k<a_colind[i+1]; ++k) d->w[p->nx+a_row[k]] = d->nz_a[k];\n"
  "      } else {\n"
  "        d->w[i] = 1.;\n"
  "      }\n"
  "    } else {\n"
  "      if (d->lam[i]==0) {\n"
  "        d->w[i] = -1.;\n"
  "      } else {\n"
  "        for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {\n"
  "          d->w[at_row[k]] = d->nz_at[k];\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "    // Copy row to KKT, zero out w\n"
  "    for (k=kkt_colind[i]; k<kkt_colind[i+1]; ++k) {\n"
  "      d->nz_kkt[k] = d->w[kkt_row[k]];\n"
  "      d->w[kkt_row[k]] = 0;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_kkt_vector\"\n"
  "template<typename T1>\n"
  "void casadi_qp_kkt_vector(casadi_qp_data<T1>* d, T1* kkt_i, casadi_int i) {\n"
  "  // Local variables\n"
  "  casadi_int k;\n"
  "  const casadi_int *h_colind, *h_row, *a_colind, *a_row, *at_colind, *at_row;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Extract sparsities\n"
  "  a_row = (a_colind = p->sp_a+2) + p->nx + 1;\n"
  "  at_row = (at_colind = p->sp_at+2) + p->na + 1;\n"
  "  h_row = (h_colind = p->sp_h+2) + p->nx + 1;\n"
  "  // Reset kkt_i to zero\n"
  "  casadi_clear(kkt_i, p->nz);\n"
  "  // Copy sparse entries\n"
  "  if (i<p->nx) {\n"
  "    for (k=h_colind[i]; k<h_colind[i+1]; ++k) kkt_i[h_row[k]] = d->nz_h[k];\n"
  "    for (k=a_colind[i]; k<a_colind[i+1]; ++k) kkt_i[p->nx+a_row[k]] = d->nz_a[k];\n"
  "  } else {\n"
  "    for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {\n"
  "      kkt_i[at_row[k]] = -d->nz_at[k];\n"
  "    }\n"
  "  }\n"
  "  // Add diagonal entry\n"
  "  kkt_i[i] -= 1.;\n"
  "}\n"
  "// SYMBOL \"qp_kkt_dot\"\n"
  "template<typename T1>\n"
  "T1 casadi_qp_kkt_dot(casadi_qp_data<T1>* d, const T1* v, casadi_int i) {\n"
  "  // Local variables\n"
  "  casadi_int k;\n"
  "  const casadi_int *h_colind, *h_row, *a_colind, *a_row, *at_colind, *at_row;\n"
  "  T1 r;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Extract sparsities\n"
  "  a_row = (a_colind = p->sp_a + 2) + p->nx + 1;\n"
  "  at_row = (at_colind = p->sp_at + 2) + p->na + 1;\n"
  "  h_row = (h_colind = p->sp_h + 2) + p->nx + 1;\n"
  "  // Scalar product with the diagonal\n"
  "  r = v[i];\n"
  "  // Scalar product with the sparse entries\n"
  "  if (i < p->nx) {\n"
  "    for (k=h_colind[i]; k<h_colind[i+1]; ++k) r -= v[h_row[k]] * d->nz_h[k];\n"
  "    for (k=a_colind[i]; k<a_colind[i+1]; ++k) r -= v[p->nx+a_row[k]] * d->nz_a[k];\n"
  "  } else {\n"
  "    for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {\n"
  "      r += v[at_row[k]] * d->nz_at[k];\n"
  "    }\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "// SYMBOL \"qp_kkt_residual\"\n"
  "template<typename T1>\n"
  "void casadi_qp_kkt_residual(casadi_qp_data<T1>* d, T1* r) {\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    if (d->lam[i]>0.) {\n"
  "      r[i] = d->ubz[i]-d->z[i];\n"
  "    } else if (d->lam[i]<0.) {\n"
  "      r[i] = d->lbz[i]-d->z[i];\n"
  "    } else if (i<p->nx) {\n"
  "      r[i] = d->lam[i]-d->infeas[i];\n"
  "    } else {\n"
  "      r[i] = d->lam[i];\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_zero_blocking\"\n"
  "template<typename T1>\n"
  "int casadi_qp_zero_blocking(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i;\n"
  "  T1 dz_max = 0;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Look for violated constraints that are not improving\n"
  "  for (i = 0; i < p->nz; ++i) {\n"
  "    if (d->dz[i] < -dz_max && d->lbz[i] - d->z[i] >= d->epr) {\n"
  "      dz_max = -d->dz[i];\n"
  "      d->index = i;\n"
  "      d->sign = -1;\n"
  "      d->msg = \"lbz violated with zero step\";\n"
  "      d->msg_ind = d->index;\n"
  "    } else if (d->dz[i] > dz_max && d->z[i] - d->ubz[i] >= d->epr) {\n"
  "      dz_max = d->dz[i];\n"
  "      d->index = i;\n"
  "      d->sign = 1;\n"
  "      d->msg = \"ubz violated with zero step\";\n"
  "      d->msg_ind = d->index;\n"
  "    }\n"
  "  }\n"
  "  return dz_max > 0;\n"
  "}\n"
  "// SYMBOL \"qp_primal_blocking\"\n"
  "template<typename T1>\n"
  "void casadi_qp_primal_blocking(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i;\n"
  "  T1 trial_z;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Check if violation with tau=0 and not improving\n"
  "  if (casadi_qp_zero_blocking(d)) {\n"
  "    d->tau = 0.;\n"
  "    return;\n"
  "  }\n"
  "  // Loop over all primal variables\n"
  "  for (i = 0; i < p->nz; ++i) {\n"
  "    if (d->dz[i] == 0.) continue; // Skip zero steps\n"
  "    // Trial primal step\n"
  "    trial_z = d->z[i] + d->tau * d->dz[i];\n"
  "    if (d->dz[i] < 0 && trial_z < d->lbz[i] - d->epr) {\n"
  "      // Trial would increase maximum infeasibility\n"
  "      d->tau = (d->lbz[i] - d->epr - d->z[i]) / d->dz[i];\n"
  "      d->index = d->lam[i] < 0. ? -1 : i;\n"
  "      d->sign = -1;\n"
  "      d->msg = \"Enforcing lbz\";\n"
  "      d->msg_ind = i;\n"
  "    } else if (d->dz[i] > 0 && trial_z > d->ubz[i] + d->epr) {\n"
  "      // Trial would increase maximum infeasibility\n"
  "      d->tau = (d->ubz[i] + d->epr - d->z[i]) / d->dz[i];\n"
  "      d->index = d->lam[i] > 0. ? -1 : i;\n"
  "      d->sign = 1;\n"
  "      d->msg = \"Enforcing ubz\";\n"
  "      d->msg_ind = i;\n"
  "    }\n"
  "    if (d->tau <= 0) return;\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_dual_breakpoints\"\n"
  "template<typename T1>\n"
  "casadi_int casadi_qp_dual_breakpoints(casadi_qp_data<T1>* d, T1* tau_list,\n"
  "                                      casadi_int* ind_list, T1 tau) {\n"
  "  // Local variables\n"
  "  casadi_int i, n_tau, loc, next_ind, tmp_ind, j;\n"
  "  T1 trial_lam, new_tau, next_tau, tmp_tau;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Dual feasibility is piecewise linear. Start with one interval [0,tau]:\n"
  "  tau_list[0] = tau;\n"
  "  ind_list[0] = -1; // no associated index\n"
  "  n_tau = 1;\n"
  "  // Find the taus corresponding to lam crossing zero and insert into list\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    if (d->dlam[i]==0.) continue; // Skip zero steps\n"
  "    if (d->lam[i]==0.) continue; // Skip inactive constraints\n"
  "    // Trial dual step\n"
  "    trial_lam = d->lam[i] + tau*d->dlam[i];\n"
  "    // Skip if no sign change\n"
  "    if (d->lam[i]>0 ? trial_lam>=0 : trial_lam<=0) continue;\n"
  "    // Location of the sign change\n"
  "    new_tau = -d->lam[i]/d->dlam[i];\n"
  "    // Where to insert the w[i]\n"
  "    for (loc=0; loc<n_tau-1; ++loc) {\n"
  "      if (new_tau<tau_list[loc]) break;\n"
  "    }\n"
  "    // Insert element\n"
  "    n_tau++;\n"
  "    next_tau=new_tau;\n"
  "    next_ind=i;\n"
  "    for (j=loc; j<n_tau; ++j) {\n"
  "      tmp_tau = tau_list[j];\n"
  "      tau_list[j] = next_tau;\n"
  "      next_tau = tmp_tau;\n"
  "      tmp_ind = ind_list[j];\n"
  "      ind_list[j] = next_ind;\n"
  "      next_ind = tmp_ind;\n"
  "    }\n"
  "  }\n"
  "  return n_tau;\n"
  "}\n"
  "// SYMBOL \"qp_dual_blocking\"\n"
  "template<typename T1>\n"
  "casadi_int casadi_qp_dual_blocking(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i, n_tau, j, k, du_index;\n"
  "  T1 tau_k, dtau, new_infeas, tau1, infeas, tinfeas;\n"
  "  const casadi_int *at_colind, *at_row;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Extract sparsities\n"
  "  at_row = (at_colind = p->sp_at+2) + p->na + 1;\n"
  "  // Dual feasibility is piecewise linear in tau. Get the intervals:\n"
  "  n_tau = casadi_qp_dual_breakpoints(d, d->w, d->iw, d->tau);\n"
  "  // No dual blocking yet\n"
  "  du_index = -1;\n"
  "  // How long step can we take without exceeding e?\n"
  "  tau_k = 0.;\n"
  "  for (j=0; j<n_tau; ++j) {\n"
  "    // Distance to the next tau (may be zero)\n"
  "    dtau = d->w[j] - tau_k;\n"
  "    // Check if maximum dual infeasibilty gets exceeded\n"
  "    for (k=0; k<p->nx; ++k) {\n"
  "      // Get infeasibility and infeasibility tangent\n"
  "      infeas  = d->infeas[k];\n"
  "      tinfeas  = d->tinfeas[k];\n"
  "      // Make sure tinfeas>0\n"
  "      if (fabs(tinfeas)<1e-14) {\n"
  "        // Skip\n"
  "        continue;\n"
  "      } else if (tinfeas<0) {\n"
  "        // Switch signs\n"
  "        infeas *= -1;\n"
  "        tinfeas *= -1;\n"
  "      }\n"
  "      // Tentative new infeasibility\n"
  "      new_infeas = infeas + dtau*tinfeas;\n"
  "      // Does infeasibility get exceeded\n"
  "      if (new_infeas > d->edu) {\n"
  "        // Sign change and exceeded\n"
  "        tau1 = fmax(tau_k, tau_k + (d->edu - infeas)/tinfeas);\n"
  "        if (tau1 < d->tau) {\n"
  "          // Enforce dual blocking constraint\n"
  "          d->tau = tau1;\n"
  "          du_index = k;\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "    // Update infeasibility\n"
  "    casadi_axpy(p->nx, fmin(d->tau - tau_k, dtau), d->tinfeas, d->infeas);\n"
  "    // Stop here if dual blocking constraint\n"
  "    if (du_index>=0) return du_index;\n"
  "    // Continue to the next tau\n"
  "    tau_k = d->w[j];\n"
  "    // Get component, break if last\n"
  "    i = d->iw[j];\n"
  "    if (i<0) break;\n"
  "    // Update sign or tinfeas\n"
  "    if (!d->neverzero[i]) {\n"
  "      // lam becomes zero, update the infeasibility tangent\n"
  "      if (i<p->nx) {\n"
  "        // Set a lam_x to zero\n"
  "        d->tinfeas[i] -= d->dlam[i];\n"
  "      } else {\n"
  "        // Set a lam_a to zero\n"
  "        for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {\n"
  "          d->tinfeas[at_row[k]] -= d->nz_at[k]*d->dlam[i];\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  return du_index;\n"
  "}\n"
  "// SYMBOL \"qp_take_step\"\n"
  "template<typename T1>\n"
  "void casadi_qp_take_step(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Get current sign\n"
  "  for (i=0; i<p->nz; ++i) d->iw[i] = d->lam[i]>0. ? 1 : d->lam[i]<0 ? -1 : 0;\n"
  "  // Take primal-dual step\n"
  "  casadi_axpy(p->nz, d->tau, d->dz, d->z);\n"
  "  casadi_axpy(p->nz, d->tau, d->dlam, d->lam);\n"
  "  // Update sign\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    // Allow sign changes for certain components\n"
  "    if (d->neverzero[i] && (d->iw[i]<0 ? d->lam[i]>0 : d->lam[i]<0)) {\n"
  "      d->iw[i]=-d->iw[i];\n"
  "    }\n"
  "    // Ensure correct sign\n"
  "    switch (d->iw[i]) {\n"
  "      case -1: d->lam[i] = fmin(d->lam[i], -p->dmin); break;\n"
  "      case  1: d->lam[i] = fmax(d->lam[i],  p->dmin); break;\n"
  "      case  0: d->lam[i] = 0.; break;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_flip_check\"\n"
  "template<typename T1>\n"
  "int casadi_qp_flip_check(casadi_qp_data<T1>* d) {\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Calculate the difference between unenforced and enforced column index\n"
  "  casadi_qp_kkt_vector(d, d->dlam, d->index);\n"
  "  // Calculate the difference between old and new column index\n"
  "  if (d->sign == 0) casadi_scal(p->nz, -1., d->dlam);\n"
  "  // Try to find a linear combination of the new columns\n"
  "  casadi_qr_solve(d->dlam, 1, 0, p->sp_v, d->nz_v, p->sp_r, d->nz_r, d->beta,\n"
  "    p->prinv, p->pc, d->w);\n"
  "  // If dlam[index]!=1, new columns must be linearly independent\n"
  "  if (fabs(d->dlam[d->index]-1.) >= 1e-12) return 0;\n"
  "  // Next, find a linear combination of the new rows\n"
  "  casadi_clear(d->dz, p->nz);\n"
  "  d->dz[d->index] = 1;\n"
  "  casadi_qr_solve(d->dz, 1, 1, p->sp_v, d->nz_v, p->sp_r, d->nz_r, d->beta,\n"
  "    p->prinv, p->pc, d->w);\n"
  "  // Normalize dlam, dz\n"
  "  casadi_scal(p->nz, 1./sqrt(casadi_dot(p->nz, d->dlam, d->dlam)), d->dlam);\n"
  "  casadi_scal(p->nz, 1./sqrt(casadi_dot(p->nz, d->dz, d->dz)), d->dz);\n"
  "  // KKT system will be singular\n"
  "  return 1;\n"
  "}\n"
  "// SYMBOL \"qp_factorize\"\n"
  "template<typename T1>\n"
  "void casadi_qp_factorize(casadi_qp_data<T1>* d) {\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Do we already have a search direction due to lost singularity?\n"
  "  if (d->has_search_dir) {\n"
  "    d->sing = 1;\n"
  "    return;\n"
  "  }\n"
  "  // Construct the KKT matrix\n"
  "  casadi_qp_kkt(d);\n"
  "  // QR factorization\n"
  "  casadi_qr(p->sp_kkt, d->nz_kkt, d->w, p->sp_v, d->nz_v, p->sp_r,\n"
  "            d->nz_r, d->beta, p->prinv, p->pc);\n"
  "  // Check singularity\n"
  "  d->sing = casadi_qr_singular(&d->mina, &d->imina, d->nz_r, p->sp_r, p->pc, 1e-12);\n"
  "}\n"
  "// SYMBOL \"qp_expand_step\"\n"
  "template<typename T1>\n"
  "void casadi_qp_expand_step(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Calculate change in Lagrangian gradient\n"
  "  casadi_clear(d->dlam, p->nx);\n"
  "  casadi_mv(d->nz_h, p->sp_h, d->dz, d->dlam, 0); // gradient of the objective\n"
  "  casadi_mv(d->nz_a, p->sp_a, d->dz + p->nx, d->dlam, 1); // gradient of the Lagrangian\n"
  "  // Step in lam[:nx]\n"
  "  casadi_scal(p->nx, -1., d->dlam);\n"
  "  // For inactive constraints, lam(x) step is zero\n"
  "  for (i = 0; i < p->nx; ++i) if (d->lam[i] == 0.) d->dlam[i] = 0.;\n"
  "  // Step in lam[nx:]\n"
  "  casadi_copy(d->dz+p->nx, p->na, d->dlam + p->nx);\n"
  "  // Step in z[nx:]\n"
  "  casadi_clear(d->dz + p->nx, p->na);\n"
  "  casadi_mv(d->nz_a, p->sp_a, d->dz, d->dz + p->nx, 0);\n"
  "  // Avoid steps that are nonzero due to numerics\n"
  "  for (i = 0; i < p->nz; ++i) if (fabs(d->dz[i]) < 1e-14) d->dz[i] = 0.;\n"
  "  // Tangent of the dual infeasibility at tau=0\n"
  "  casadi_clear(d->tinfeas, p->nx);\n"
  "  casadi_mv(d->nz_h, p->sp_h, d->dz, d->tinfeas, 0);\n"
  "  casadi_mv(d->nz_a, p->sp_a, d->dlam + p->nx, d->tinfeas, 1);\n"
  "  casadi_axpy(p->nx, 1., d->dlam, d->tinfeas);\n"
  "}\n"
  "// SYMBOL \"casadi_qp_pr_direction\"\n"
  "template<typename T1>\n"
  "int casadi_qp_pr_direction(casadi_qp_data<T1>* d) {\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    if (d->lbz[i] - d->z[i] >= d->epr) {\n"
  "      // Prevent further violation of lower bound\n"
  "      if (d->dz[i] < 0 || d->dlam[i] > 0) return 1;\n"
  "    } else if (d->z[i] - d->ubz[i] >= d->epr) {\n"
  "      // Prevent further violation of upper bound\n"
  "      if (d->dz[i] > 0 || d->dlam[i] < 0) return 1;\n"
  "    }\n"
  "  }\n"
  "  return 0;\n"
  "}\n"
  "// SYMBOL \"casadi_qp_du_direction\"\n"
  "template<typename T1>\n"
  "int casadi_qp_du_direction(casadi_qp_data<T1>* d) {\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  for (i=0; i<p->nx; ++i) {\n"
  "    // Prevent further increase in dual infeasibility\n"
  "    if (d->infeas[i] <= -d->edu && d->tinfeas[i] < -1e-12) {\n"
  "      return 1;\n"
  "    } else if (d->infeas[i] >= d->edu && d->tinfeas[i] > 1e-12) {\n"
  "      return 1;\n"
  "    }\n"
  "  }\n"
  "  return 0;\n"
  "}\n"
  "// SYMBOL \"qp_enforceable\"\n"
  "template<typename T1>\n"
  "int casadi_qp_enforceable(casadi_qp_data<T1>* d, casadi_int i, casadi_int s) {\n"
  "  // Local variables\n"
  "  casadi_int k;\n"
  "  const casadi_int *at_colind, *at_row;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Can always enforce if not at bound\n"
  "  if (fabs(d->infeas[i]) < d->edu) return 1;\n"
  "  // AT sparsity\n"
  "  at_colind = p->sp_at + 2;\n"
  "  at_row = at_colind + p->na + 1;\n"
  "  // Can we set lam[i] := s*DMIN without exceeding edu?\n"
  "  if (i<p->nx) {\n"
  "    return (s < 0) == (d->infeas[i] > 0);\n"
  "  } else {\n"
  "    for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {\n"
  "      if (d->nz_at[k] > 0) {\n"
  "        if ((s > 0) == (d->infeas[at_row[k]] > 0)) return 0;\n"
  "      } else if (d->nz_at[k] < 0) {\n"
  "        if ((s < 0) == (d->infeas[at_row[k]] > 0)) return 0;\n"
  "      }\n"
  "    }\n"
  "    return 1;\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_singular_step\"\n"
  "// C-REPLACE \"static_cast<T1*>(0)\" \"0\"\n"
  "template<typename T1>\n"
  "int casadi_qp_singular_step(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  T1 tau_test, tau;\n"
  "  casadi_int nnz_kkt, nk, k, i, best_k, best_neg, neg;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Find the columns that take part in any linear combination\n"
  "  for (i = 0; i < p->nz; ++i) d->lincomb[i] = 0;\n"
  "  for (k = 0; k < d->sing; ++k) {\n"
  "    if (!d->has_search_dir) {\n"
  "      casadi_qr_colcomb(d->dlam, d->nz_r, p->sp_r, p->pc, 1e-12, k);\n"
  "    }\n"
  "    for (i = 0; i < p->nz; ++i) if (fabs(d->dlam[i]) >= 1e-12) d->lincomb[i]++;\n"
  "  }\n"
  "  if (d->has_search_dir) {\n"
  "    // One, given search direction\n"
  "    nk = 1;\n"
  "  } else {\n"
  "    // QR factorization of the transpose\n"
  "    casadi_trans(d->nz_kkt, p->sp_kkt, d->nz_v, p->sp_kkt, d->iw);\n"
  "    nnz_kkt = p->sp_kkt[2+p->nz]; // kkt_colind[nz]\n"
  "    casadi_copy(d->nz_v, nnz_kkt, d->nz_kkt);\n"
  "    casadi_qr(p->sp_kkt, d->nz_kkt, d->w, p->sp_v, d->nz_v, p->sp_r, d->nz_r,\n"
  "              d->beta, p->prinv, p->pc);\n"
  "    // For all nullspace vectors\n"
  "    nk = casadi_qr_singular(static_cast<T1*>(0), 0, d->nz_r, p->sp_r, p->pc, 1e-12);\n"
  "  }\n"
  "  // Best flip\n"
  "  best_k = best_neg = -1;\n"
  "  tau = p->inf;\n"
  "  for (k=0; k<nk; ++k) {\n"
  "    if (!d->has_search_dir) {\n"
  "      // Get a linear combination of the rows in kkt\n"
  "      casadi_qr_colcomb(d->dz, d->nz_r, p->sp_r, p->pc, 1e-12, k);\n"
  "    }\n"
  "    // Which constraints can be flipped in order to increase rank?\n"
  "    for (i=0; i<p->nz; ++i) {\n"
  "      d->iw[i] = d->lincomb[i] && fabs(casadi_qp_kkt_dot(d, d->dz, i)) > 1e-12;\n"
  "    }\n"
  "    // Calculate step, dz and dlam\n"
  "    casadi_qp_expand_step(d);\n"
  "    // Try both positive and negative direction\n"
  "    for (neg = 0; neg < 2; ++neg) {\n"
  "      // Negate direction\n"
  "      if (neg) {\n"
  "        casadi_scal(p->nz, -1., d->dz);\n"
  "        casadi_scal(p->nz, -1., d->dlam);\n"
  "        casadi_scal(p->nx, -1., d->tinfeas);\n"
  "      }\n"
  "      // Make sure primal infeasibility doesn't exceed limits\n"
  "      if (casadi_qp_pr_direction(d)) continue;\n"
  "      // Make sure dual infeasibility doesn't exceed limits\n"
  "      if (casadi_qp_du_direction(d)) continue;\n"
  "      // Loop over potential active set changes\n"
  "      for (i=0; i<p->nz; ++i) {\n"
  "        // Skip if no rank increase\n"
  "        if (!d->iw[i]) continue;\n"
  "        // Enforced or not?\n"
  "        if (d->lam[i]==0.) {\n"
  "          if (d->z[i] <= d->ubz[i] && (d->z[i] >= d->lbz[i] ?\n"
  "              d->dz[i] < -1e-12 : d->dz[i] > 1e-12)) {\n"
  "            // Enforce lower bound?\n"
  "            if (!d->neverlower[i]\n"
  "                && (tau_test = (d->lbz[i] - d->z[i]) / d->dz[i]) < tau\n"
  "                && casadi_qp_enforceable(d, i, -1)) {\n"
  "              tau = tau_test;\n"
  "              d->r_index = i;\n"
  "              d->r_sign = -1;\n"
  "              best_k = k;\n"
  "              best_neg = neg;\n"
  "            }\n"
  "          } else if (d->z[i] >= d->lbz[i] && (d->z[i] <= d->ubz[i] ?\n"
  "              d->dz[i] > 1e-12 : d->dz[i] < -1e-12)) {\n"
  "            // Enforce upper bound?\n"
  "            if (!d->neverupper[i]\n"
  "                && (tau_test = (d->ubz[i] - d->z[i]) / d->dz[i]) < tau\n"
  "                && casadi_qp_enforceable(d, i, 1)) {\n"
  "              tau = tau_test;\n"
  "              d->r_index = i;\n"
  "              d->r_sign = 1;\n"
  "              best_k = k;\n"
  "              best_neg = neg;\n"
  "            }\n"
  "          }\n"
  "        } else if (!d->neverzero[i]) {\n"
  "          // Drop a constraint?\n"
  "          if (d->lam[i] > 0 ? d->dlam[i] < -1e-12 : d->dlam[i] > 1e-12) {\n"
  "            if ((tau_test = -d->lam[i] / d->dlam[i]) < tau) {\n"
  "              tau = tau_test;\n"
  "              d->r_index = i;\n"
  "              d->r_sign = 0;\n"
  "              best_k = k;\n"
  "              best_neg = neg;\n"
  "            }\n"
  "          }\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  // Can we restore feasibility?\n"
  "  if (d->r_index < 0) return 1;\n"
  "  // Recalculate direction, if needed\n"
  "  if (--k != best_k) {\n"
  "    // Need to recalculate direction\n"
  "    casadi_qr_colcomb(d->dz, d->nz_r, p->sp_r, p->pc, 1e-12, best_k);\n"
  "    casadi_qp_expand_step(d);\n"
  "    if (best_neg) tau *= -1;\n"
  "  } else if (--neg != best_neg) {\n"
  "    // No need to recalculate, but opposite direction\n"
  "    tau *= -1;\n"
  "  }\n"
  "  // Scale step so that that tau=1 corresponds to a full step\n"
  "  casadi_scal(p->nz, tau, d->dz);\n"
  "  casadi_scal(p->nz, tau, d->dlam);\n"
  "  casadi_scal(p->nx, tau, d->tinfeas);\n"
  "  return 0;\n"
  "}\n"
  "// SYMBOL \"qp_calc_step\"\n"
  "template<typename T1>\n"
  "int casadi_qp_calc_step(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Reset returns\n"
  "  d->r_index = -1;\n"
  "  d->r_sign = 0;\n"
  "  // Handle singularity\n"
  "  if (d->sing) return casadi_qp_singular_step(d);\n"
  "  // Negative KKT residual\n"
  "  casadi_qp_kkt_residual(d, d->dz);\n"
  "  // Solve to get step in z[:nx] and lam[nx:]\n"
  "  casadi_qr_solve(d->dz, 1, 1, p->sp_v, d->nz_v, p->sp_r, d->nz_r, d->beta,\n"
  "                  p->prinv, p->pc, d->w);\n"
  "  // Have step in dz[:nx] and dlam[nx:]. Calculate complete dz and dlam\n"
  "  casadi_qp_expand_step(d);\n"
  "  // Successful return\n"
  "  return 0;\n"
  "}\n"
  "// SYMBOL \"qp_calc_sens\"\n"
  "template<typename T1>\n"
  "void casadi_qp_calc_sens(casadi_qp_data<T1>* d, casadi_int i) {\n"
  "  // Local variables\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Calculate sensitivities in decreasing dual infeasibility index i\n"
  "  casadi_clear(d->sens, p->nz);\n"
  "  if (i >= 0) {\n"
  "    d->sens[i] = d->infeas[i] > 0 ? -1. : 1.;\n"
  "    casadi_mv(d->nz_a, p->sp_a, d->sens, d->sens + p->nx, 0);\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_calc_dependent\"\n"
  "template<typename T1>\n"
  "void casadi_qp_calc_dependent(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i;\n"
  "  T1 r;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Calculate f\n"
  "  d->f = casadi_bilin(d->nz_h, p->sp_h, d->z, d->z)/2.\n"
  "       + casadi_dot(p->nx, d->z, d->g);\n"
  "  // Calculate z[nx:]\n"
  "  casadi_clear(d->z+p->nx, p->na);\n"
  "  casadi_mv(d->nz_a, p->sp_a, d->z, d->z+p->nx, 0);\n"
  "  // Calculate gradient of the Lagrangian\n"
  "  casadi_copy(d->g, p->nx, d->infeas);\n"
  "  casadi_mv(d->nz_h, p->sp_h, d->z, d->infeas, 0);\n"
  "  casadi_mv(d->nz_a, p->sp_a, d->lam+p->nx, d->infeas, 1);\n"
  "  // Calculate lam[:nx] without changing the sign accidentally, dual infeasibility\n"
  "  for (i=0; i<p->nx; ++i) {\n"
  "    // No change if zero\n"
  "    if (d->lam[i]==0) continue;\n"
  "    // lam[i] with no sign restrictions\n"
  "    r = -d->infeas[i];\n"
  "    if (d->lam[i]>0) {\n"
  "      if (d->neverzero[i] && !d->neverlower[i]) {\n"
  "        d->lam[i] = r==0 ? p->dmin : r; // keep sign if r==0\n"
  "      } else {\n"
  "        d->lam[i] = fmax(r, p->dmin); // no sign change\n"
  "      }\n"
  "    } else {\n"
  "      if (d->neverzero[i] && !d->neverupper[i]) {\n"
  "        d->lam[i] = r==0 ? -p->dmin : r; // keep sign if r==0\n"
  "      } else {\n"
  "        d->lam[i] = fmin(r, -p->dmin); // no sign change\n"
  "      }\n"
  "    }\n"
  "    // Update dual infeasibility\n"
  "    d->infeas[i] += d->lam[i];\n"
  "  }\n"
  "  // Calculate primal and dual error\n"
  "  casadi_qp_pr(d);\n"
  "  casadi_qp_du(d);\n"
  "  // Acceptable primal and dual error\n"
  "  d->epr = fmax(d->pr, (0.5 * p->constr_viol_tol / p->dual_inf_tol) * d->du);\n"
  "  d->edu = fmax(d->du, (0.5 * p->dual_inf_tol / p->constr_viol_tol) * d->pr);\n"
  "  // Sensitivity in decreasing |du|\n"
  "  casadi_qp_calc_sens(d, d->idu);\n"
  "}\n"
  "// SYMBOL \"qp_linesearch\"\n"
  "template<typename T1>\n"
  "void casadi_qp_linesearch(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int du_index;\n"
  "  // Start with a full step and no active set change\n"
  "  d->sign = 0;\n"
  "  d->index = -1;\n"
  "  d->tau = 1.;\n"
  "  // Find largest possible step without exceeding acceptable |pr|\n"
  "  casadi_qp_primal_blocking(d);\n"
  "  // Find largest possible step without exceeding acceptable |du|\n"
  "  du_index = casadi_qp_dual_blocking(d);\n"
  "  // Take primal-dual step, avoiding accidental sign changes for lam\n"
  "  casadi_qp_take_step(d);\n"
  "  // Handle dual blocking constraints\n"
  "  if (du_index >= 0) {\n"
  "    // Sensititivity in decreasing du_index\n"
  "    casadi_qp_calc_sens(d, du_index);\n"
  "    // Find corresponding index\n"
  "    casadi_qp_du_index(d);\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_flip\"\n"
  "template<typename T1>\n"
  "void casadi_qp_flip(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Try to restore regularity if possible\n"
  "  if (d->index == -1 && d->r_index >= 0) {\n"
  "    if (d->r_sign != 0 || casadi_qp_du_check(d, d->r_index)) {\n"
  "      d->index = d->r_index;\n"
  "      d->sign = d->r_sign;\n"
  "      if (d->sign > 0) {\n"
  "        d->msg = \"Enforced ubz for regularity\";\n"
  "      } else if (d->sign < 0) {\n"
  "        d->msg = \"Enforced lbz for regularity\";\n"
  "      } else if (d->lam[d->index] > 0) {\n"
  "        d->msg = \"Dropped ubz for regularity\";\n"
  "      } else {\n"
  "        d->msg = \"Dropped lbz for regularity\";\n"
  "      }\n"
  "      d->msg_ind = d->index;\n"
  "    }\n"
  "  }\n"
  "  // If nonsingular and nonzero error, try to flip a constraint\n"
  "  if (!d->sing && d->index == -1) {\n"
  "    if (d->pr * p->dual_inf_tol >= p->constr_viol_tol * d->du) {\n"
  "      // Improve primal feasibility if dominating\n"
  "      if (d->pr >= p->constr_viol_tol) casadi_qp_pr_index(d);\n"
  "    } else {\n"
  "      // Improve dual feasibility if dominating\n"
  "      if (d->du >= p->dual_inf_tol) casadi_qp_du_index(d);\n"
  "    }\n"
  "  }\n"
  "  // No search direction given by default\n"
  "  d->has_search_dir = 0;\n"
  "  // If a constraint was added\n"
  "  if (d->index >= 0) {\n"
  "    // Detect singularity before it happens and get nullspace vectors\n"
  "    if (!d->sing) d->has_search_dir = casadi_qp_flip_check(d);\n"
  "    // Perform the active-set change\n"
  "    d->lam[d->index] = d->sign==0 ? 0 : d->sign > 0 ? p->dmin : -p->dmin;\n"
  "    // Recalculate primal and dual infeasibility\n"
  "    casadi_qp_calc_dependent(d);\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_prepare\"\n"
  "template<typename T1>\n"
  "int casadi_qp_prepare(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Calculate dependent quantities\n"
  "  casadi_qp_calc_dependent(d);\n"
  "  // Make an active set change\n"
  "  casadi_qp_flip(d);\n"
  "  // Form and factorize the KKT system\n"
  "  casadi_qp_factorize(d);\n"
  "  // Termination message\n"
  "  if (!d->sing && d->index == -1) {\n"
  "    d->status = QP_SUCCESS;\n"
  "    d->msg = \"Converged\";\n"
  "    d->msg_ind = -2;\n"
  "    return 1;\n"
  "  } else if (d->iter >= p->max_iter) {\n"
  "    d->status = QP_MAX_ITER;\n"
  "    d->msg = \"Max iter\";\n"
  "    d->msg_ind = -2;\n"
  "    return 1;\n"
  "  } else if (!d->sing && d->ipr < 0 && d->idu < 0) {\n"
  "    d->status = QP_SUCCESS;\n"
  "    d->msg = \"No primal or dual error\";\n"
  "    d->msg_ind = -2;\n"
  "    return 1;\n"
  "  } else {\n"
  "    // Keep iterating\n"
  "    return 0;\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_iterate\"\n"
  "template<typename T1>\n"
  "int casadi_qp_iterate(casadi_qp_data<T1>* d) {\n"
  "  // Reset message flag\n"
  "  d->msg = 0;\n"
  "  // Start a new iteration\n"
  "  d->iter++;\n"
  "  // Calculate search direction\n"
  "  if (casadi_qp_calc_step(d)) {\n"
  "    d->status = QP_NO_SEARCH_DIR;\n"
  "    return 1;\n"
  "  }\n"
  "  // Line search in the calculated direction\n"
  "  casadi_qp_linesearch(d);\n"
  "  // Keep iterating\n"
  "  return 0;\n"
  "}\n"
  "// The following routines require stdio\n"
  "#ifndef CASADI_PRINTF\n"
  "// SYMBOL \"qp_print_header\"\n"
  "template<typename T1>\n"
  "int casadi_qp_print_header(casadi_qp_data<T1>* d, char* buf, size_t buf_sz) {\n"
  "  int flag;\n"
  "  // Print to string\n"
  "  flag = snprintf(buf, buf_sz, \"%5s %5s %9s %9s %5s %9s %5s %9s %5s %9s  %4s\",\n"
  "          \"Iter\", \"Sing\", \"fk\", \"|pr|\", \"con\", \"|du|\", \"var\",\n"
  "          \"min_R\", \"con\", \"last_tau\", \"Note\");\n"
  "  // Check if error\n"
  "  if (flag < 0) {\n"
  "    d->status = QP_PRINTING_ERROR;\n"
  "    return 1;\n"
  "  }\n"
  "  // Successful return\n"
  "  return 0;\n"
  "}\n"
  "// SYMBOL \"qp_print_colcomb\"\n"
  "template<typename T1>\n"
  "int casadi_qp_print_colcomb(casadi_qp_data<T1>* d, char* buf, size_t buf_sz, casadi_int j) {\n"
  "  casadi_int num_size, n_print, i, k, buf_offset, val;\n"
  "  size_t b;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  casadi_qr_colcomb(d->dlam, d->nz_r, p->sp_r, p->pc, 1e-12, j);\n"
  "  // Determine max printing size\n"
  "  num_size = 1;\n"
  "  val = p->nz-1;\n"
  "  while (val) {\n"
  "    val/=10;\n"
  "    num_size++;\n"
  "  }\n"
  "  if (buf_sz<=4) return 1;\n"
  "  // How many numbers can be printed?\n"
  "  // Need some extra space for '...'\n"
  "  // and null\n"
  "  n_print = (buf_sz-4)/num_size;\n"
  "  // Clear buffer\n"
  "  for (b=0;b<buf_sz;++b) buf[b]=' ';\n"
  "  buf_offset = 0;\n"
  "  for (i=0;i<p->nz;++i) {\n"
  "    if (fabs(d->dlam[i]) >= 1e-12) {\n"
  "      if (n_print==0) {\n"
  "        buf[buf_sz-4] = '.';\n"
  "        buf[buf_sz-3] = '.';\n"
  "        buf[buf_sz-2] = '.';\n"
  "        buf[buf_sz-1] = '\\0';\n"
  "        return 1;\n"
  "      }\n"
  "      n_print--;\n"
  "      snprintf(buf+buf_offset, num_size, \"%d\", static_cast<int>(i));\n"
  "      // Clear null chars\n"
  "      for (k=0;k<num_size;++k) {\n"
  "        if (buf[buf_offset+k]=='\\0') buf[buf_offset+k] = ' ';\n"
  "      }\n"
  "      buf_offset += num_size;\n"
  "    }\n"
  "  }\n"
  "  buf[buf_sz-1] = '\\0';\n"
  "  // Successful return\n"
  "  return 0;\n"
  "}\n"
  "// SYMBOL \"qp_print_iteration\"\n"
  "template<typename T1>\n"
  "int casadi_qp_print_iteration(casadi_qp_data<T1>* d, char* buf, int buf_sz) {\n"
  "  int flag;\n"
  "  // Print iteration data without note to string\n"
  "  flag = snprintf(buf, buf_sz,\n"
  "    \"%5d %5d %9.2g %9.2g %5d %9.2g %5d %9.2g %5d %9.2g  \",\n"
  "    static_cast<int>(d->iter), static_cast<int>(d->sing), d->f, d->pr,\n"
  "    static_cast<int>(d->ipr), d->du, static_cast<int>(d->idu),\n"
  "    d->mina, static_cast<int>(d->imina), d->tau);\n"
  "  // Check if error\n"
  "  if (flag < 0) {\n"
  "    d->status = QP_PRINTING_ERROR;\n"
  "    return 1;\n"
  "  }\n"
  "  // Rest of buffer reserved for iteration note\n"
  "  buf += flag;\n"
  "  buf_sz -= flag;\n"
  "  // Print iteration note, if any\n"
  "  if (d->msg) {\n"
  "    if (d->msg_ind > -2) {\n"
  "      flag = snprintf(buf, buf_sz, \"%s, i=%d\", d->msg, static_cast<int>(d->msg_ind));\n"
  "    } else {\n"
  "      flag = snprintf(buf, buf_sz, \"%s\", d->msg);\n"
  "    }\n"
  "    // Check if error\n"
  "    if (flag < 0) {\n"
  "      d->status = QP_PRINTING_ERROR;\n"
  "      return 1;\n"
  "    }\n"
  "  }\n"
  "  // Successful return\n"
  "  return 0;\n"
  "}\n"
  "#endif  // CASADI_PRINTF\n";

const char* casadi_nlp_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"nlpsol_prob\"\n"
  "template<typename T1>\n"
  "struct casadi_nlpsol_prob {\n"
  "  casadi_int nx, ng, np;\n"
  "};\n"
  "// C-REPLACE \"casadi_nlpsol_prob<T1>\" \"struct casadi_nlpsol_prob\"\n"
  "// SYMBOL \"nlpsol_data\"\n"
  "template<typename T1>\n"
  "struct casadi_nlpsol_data {\n"
  "  // Problem structure\n"
  "  const casadi_nlpsol_prob<T1>* prob;\n"
  "  // Variable bounds\n"
  "  T1 *lbz, *ubz;\n"
  "  // Parameter values\n"
  "  const T1 *p;\n"
  "  // Current primal solution\n"
  "  T1 *z;\n"
  "  // Current dual solution\n"
  "  T1 *lam, *lam_p;\n"
  "  // Outputs\n"
  "  T1 f;\n"
  "};\n"
  "// C-REPLACE \"casadi_nlpsol_data<T1>\" \"struct casadi_nlpsol_data\"\n"
  "// SYMBOL \"nlpsol_work\"\n"
  "template<typename T1>\n"
  "void casadi_nlpsol_work(const casadi_nlpsol_prob<T1>* p, casadi_int* sz_iw, casadi_int* sz_w) {\n"
  "  // Reset sz_w, sz_iw\n"
  "  *sz_w = *sz_iw = 0;\n"
  "  *sz_w += p->nx + p->ng; // z\n"
  "  *sz_w += p->nx + p->ng; // lbz\n"
  "  *sz_w += p->nx + p->ng; // ubz\n"
  "  *sz_w += p->nx + p->ng; // lam\n"
  "  *sz_w += p->np;         // lam_p\n"
  "}\n"
  "// SYMBOL \"nlpsol_init\"\n"
  "template<typename T1>\n"
  "void casadi_nlpsol_init(casadi_nlpsol_data<T1>* d, casadi_int** iw, T1** w) {\n"
  "  // Local variables\n"
  "  casadi_int nx, ng, np;\n"
  "  const casadi_nlpsol_prob<T1>* p = d->prob;\n"
  "  nx = p->nx;\n"
  "  ng = p->ng;\n"
  "  np = p->np;\n"
  "  // Get matrix number of nonzeros\n"
  "  d->z = *w; *w += nx + ng;\n"
  "  d->lbz = *w; *w += nx + ng;\n"
  "  d->ubz = *w; *w += nx + ng;\n"
  "  d->lam = *w; *w += nx + ng;\n"
  "  d->lam_p = *w; *w += np;\n"
  "}\n";

const char* casadi_sqpmethod_str =
  "// NOLINT(legal/copyright)\n"
  "// C-REPLACE \"casadi_nlpsol_prob<T1>\" \"struct casadi_nlpsol_prob\"\n"
  "// SYMBOL \"sqpmethod_prob\"\n"
  "template<typename T1>\n"
  "struct casadi_sqpmethod_prob {\n"
  "  const casadi_nlpsol_prob<T1>* nlp;\n"
  "  // Sparsity patterns\n"
  "  const casadi_int *sp_h, *sp_a, *sp_hr;\n"
  "  casadi_int merit_memsize;\n"
  "  casadi_int max_iter_ls;\n"
  "};\n"
  "// C-REPLACE \"casadi_sqpmethod_prob<T1>\" \"struct casadi_sqpmethod_prob\"\n"
  "// SYMBOL \"sqpmethod_data\"\n"
  "template<typename T1>\n"
  "struct casadi_sqpmethod_data {\n"
  "  // Problem structure\n"
  "  const casadi_sqpmethod_prob<T1>* prob;\n"
  "  T1* z_cand;\n"
  "  // Lagrange gradient in the next iterate\n"
  "  T1 *gLag, *gLag_old;\n"
  "  // Gradient of the objective\n"
  "  T1 *gf;\n"
  "  // Bounds of the QP\n"
  "  T1 *lbdz, *ubdz;\n"
  "  // QP solution\n"
  "  T1 *dx, *dlam;\n"
  "  // Hessian approximation\n"
  "  T1 *Bk;\n"
  "  // Jacobian\n"
  "  T1* Jk;\n"
  "  // merit_mem\n"
  "  T1* merit_mem;\n"
  "};\n"
  "// C-REPLACE \"casadi_sqpmethod_data<T1>\" \"struct casadi_sqpmethod_data\"\n"
  "// SYMBOL \"sqpmethod_work\"\n"
  "template<typename T1>\n"
  "void casadi_sqpmethod_work(const casadi_sqpmethod_prob<T1>* p,\n"
  "    casadi_int* sz_iw, casadi_int* sz_w) {\n"
  "  // Local variables\n"
  "  casadi_int nnz_h, nnz_a, nx, ng;\n"
  "  nnz_h = p->sp_h[2+p->sp_h[1]];\n"
  "  nnz_a = p->sp_a[2+p->sp_a[1]];\n"
  "  nx = p->nlp->nx;\n"
  "  ng = p->nlp->ng;\n"
  "  // Reset sz_w, sz_iw\n"
  "  *sz_w = *sz_iw = 0;\n"
  "  if (p->max_iter_ls>0) *sz_w += nx + ng; // z_cand\n"
  "  // Lagrange gradient in the next iterate\n"
  "  *sz_w += nx; // gLag\n"
  "  *sz_w += nx; // gLag_old\n"
  "  // Gradient of the objective\n"
  "  *sz_w += nx; // gf\n"
  "  // Bounds of the QP\n"
  "  *sz_w += nx + ng; // lbdz\n"
  "  *sz_w += nx + ng; // ubdz\n"
  "  // QP solution\n"
  "  *sz_w += nx; // dx\n"
  "  *sz_w += nx + ng; // dlam\n"
  "  // Hessian approximation\n"
  "  *sz_w += nnz_h; // Bk\n"
  "  // Jacobian\n"
  "  *sz_w += nnz_a; // Jk\n"
  "  // merit_mem\n"
  "  if (p->max_iter_ls>0) *sz_w += p->merit_memsize;\n"
  "}\n"
  "// SYMBOL \"sqpmethod_init\"\n"
  "template<typename T1>\n"
  "void casadi_sqpmethod_init(casadi_sqpmethod_data<T1>* d, casadi_int** iw, T1** w) {\n"
  "  // Local variables\n"
  "  casadi_int nnz_h, nnz_a, nx, ng;\n"
  "  const casadi_sqpmethod_prob<T1>* p = d->prob;\n"
  "  // Get matrix number of nonzeros\n"
  "  nnz_h = p->sp_h[2+p->sp_h[1]];\n"
  "  nnz_a = p->sp_a[2+p->sp_a[1]];\n"
  "  nx = p->nlp->nx;\n"
  "  ng = p->nlp->ng;\n"
  "  if (p->max_iter_ls>0) {\n"
  "    d->z_cand = *w;\n"
  "    *w += nx + ng;\n"
  "  }\n"
  "  // Lagrange gradient in the next iterate\n"
  "  d->gLag = *w; *w += nx;\n"
  "  d->gLag_old = *w; *w += nx;\n"
  "  // Gradient of the objective\n"
  "  d->gf = *w; *w += nx;\n"
  "  // Bounds of the QP\n"
  "  d->lbdz = *w; *w += nx + ng;\n"
  "  d->ubdz = *w; *w += nx + ng;\n"
  "  // QP solution\n"
  "  d->dx = *w; *w += nx;\n"
  "  d->dlam = *w; *w += nx + ng;\n"
  "  // Hessian approximation\n"
  "  d->Bk = *w; *w += nnz_h;\n"
  "  // Jacobian\n"
  "  d->Jk = *w; *w += nnz_a;\n"
  "  // merit_mem\n"
  "  if (p->max_iter_ls>0) {\n"
  "    d->merit_mem = *w;\n"
  "    *w += p->merit_memsize;\n"
  "  }\n"
  "}\n";

const char* casadi_bfgs_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"bfgs\"\n"
  "// BFGS update\n"
  "template<typename T1>\n"
  "void casadi_bfgs(const casadi_int* sp_h, T1* h, const T1* dx,\n"
  "                 const T1* glag, const T1* glag_old, T1* w) {\n"
  "  // Local variables\n"
  "  casadi_int nx;\n"
  "  T1 *yk, *qk, dxBkdx, omega, theta, phi;\n"
  "  // Dimension\n"
  "  nx = sp_h[0];\n"
  "  // Work vectors\n"
  "  yk = w; w += nx;\n"
  "  qk = w; w += nx;\n"
  "  // yk = glag - glag_old\n"
  "  casadi_copy(glag, nx, yk);\n"
  "  casadi_axpy(nx, -1., glag_old, yk);\n"
  "  // qk = H*dx\n"
  "  casadi_clear(qk, nx);\n"
  "  casadi_mv(h, sp_h, dx, qk, 0);\n"
  "  // Calculating theta\n"
  "  dxBkdx = casadi_dot(nx, dx, qk);\n"
  "  // C-REPLACE \"if_else\" \"casadi_if_else\"\n"
  "  omega = if_else(casadi_dot(nx, yk, dx) < 0.2 * casadi_dot(nx, dx, qk),\n"
  "                  0.8 * dxBkdx / (dxBkdx - casadi_dot(nx, dx, yk)), 1);\n"
  "  // yk = omega * yk + (1 - omega) * qk;\n"
  "  casadi_scal(nx, omega, yk);\n"
  "  casadi_axpy(nx, 1 - omega, qk, yk);\n"
  "  theta = 1. / casadi_dot(nx, dx, yk);\n"
  "  phi = 1. / casadi_dot(nx, qk, dx);\n"
  "  // Update H\n"
  "  casadi_rank1(h, sp_h, theta, yk, yk);\n"
  "  casadi_rank1(h, sp_h, -phi, qk, qk);\n"
  "}\n"
  "// SYMBOL \"bfgs_reset\"\n"
  "// Removes off-diagonal entries\n"
  "template<typename T1>\n"
  "void casadi_bfgs_reset(const casadi_int* sp_h, T1* h) {\n"
  "  casadi_int ncol, c, k;\n"
  "  const casadi_int *colind, *row;\n"
  "  ncol = sp_h[1];\n"
  "  colind = sp_h+2; row = sp_h+ncol+3;\n"
  "  for (c=0; c<ncol; ++c) {\n"
  "    for (k=colind[c]; k<colind[c+1]; ++k) {\n"
  "      if (c!=row[k]) h[k] = 0;\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_regularize_str =
  "// NOLINT(legal/copyright)\n"
  "// C-REPLACE \"fmin\" \"casadi_fmin\"\n"
  "// SYMBOL \"lb_eig\"\n"
  "// Use Gershgorin to finds upper and lower bounds on the eigenvalues\n"
  "template<typename T1>\n"
  "T1 casadi_lb_eig(const casadi_int* sp_h, const T1* h) {\n"
  "  // Local variables\n"
  "  casadi_int ncol, c, k;\n"
  "  T1 center, radius;\n"
  "  const casadi_int *colind, *row;\n"
  "  // Return value\n"
  "  T1 lb_eig = 0;\n"
  "  // Get sparsity\n"
  "  ncol = sp_h[1];\n"
  "  colind = sp_h+2; row = sp_h+ncol+3;\n"
  "  for (c=0; c<ncol; ++c) {\n"
  "    // Calculate Gershgorin discs\n"
  "    center = 0;\n"
  "    radius = 0;\n"
  "    for (k=colind[c]; k<colind[c+1]; ++k) {\n"
  "      if (row[k]==c) {\n"
  "        center = h[k];\n"
  "      } else {\n"
  "        radius += fabs(h[k]);\n"
  "      }\n"
  "    }\n"
  "    // Update the eigenvalue estimates\n"
  "    if (c==0) {\n"
  "      lb_eig = center - radius;\n"
  "    } else {\n"
  "      lb_eig = fmin(lb_eig, center - radius);\n"
  "    }\n"
  "  }\n"
  "  return lb_eig;\n"
  "}\n"
  "// SYMBOL \"regularize\"\n"
  "// Add a multiple of the identity matrix to the diagonal\n"
  "template<typename T1>\n"
  "void casadi_regularize(const casadi_int* sp_h, T1* h, T1 reg) {\n"
  "  // Local variables\n"
  "  casadi_int ncol, c, k;\n"
  "  const casadi_int *colind, *row;\n"
  "  // Get sparsity\n"
  "  ncol = sp_h[1];\n"
  "  colind = sp_h+2; row = sp_h+ncol+3;\n"
  "  // Shift diagonal entries\n"
  "  for (c=0; c<ncol; ++c) {\n"
  "    for (k=colind[c]; k<colind[c+1]; ++k) {\n"
  "      if (row[k]==c) h[k] += reg;\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_newton_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"newton_mem\"\n"
  "template<typename T1>\n"
  "struct casadi_newton_mem {\n"
  "  casadi_int n;\n"
  "  T1 abstol;\n"
  "  T1 abstol_step;\n"
  "  T1* x;\n"
  "  T1* g;\n"
  "  T1* jac_g_x;\n"
  "  const casadi_int* sp_a;\n"
  "  const casadi_int* sp_v;\n"
  "  const casadi_int* sp_r;\n"
  "  const casadi_int* prinv;\n"
  "  const casadi_int* pc;\n"
  "  T1* lin_w;\n"
  "  T1* lin_v;\n"
  "  T1* lin_r;\n"
  "  T1* lin_beta;\n"
  "};\n"
  "// C-REPLACE \"casadi_newton_mem<T1>\" \"struct casadi_newton_mem\"\n"
  "// SYMBOL \"newton\"\n"
  "template<typename T1>\n"
  "int casadi_newton(const casadi_newton_mem<T1>* m) {\n"
  "    // Check tolerance on residual\n"
  "    if (m->abstol>0 && casadi_norm_inf(m->n, m->g) <= m->abstol) return 1;\n"
  "    // Factorize J\n"
  "    casadi_qr(m->sp_a, m->jac_g_x, m->lin_w,\n"
  "              m->sp_v,  m->lin_v, m->sp_r, m->lin_r, m->lin_beta,\n"
  "              m->prinv, m->pc);\n"
  "    // Solve J^(-1) g\n"
  "    casadi_qr_solve(m->g, 1, 0, m->sp_v, m->lin_v, m->sp_r, m->lin_r, m->lin_beta,\n"
  "                    m->prinv, m->pc, m->lin_w);\n"
  "    // Update Xk+1 = Xk - J^(-1) g\n"
  "    casadi_axpy(m->n, -1., m->g, m->x);\n"
  "    // Check tolerance on step\n"
  "    if (m->abstol_step>0 && casadi_norm_inf(m->n, m->g) <= m->abstol_step) return 2;\n"
  "    // We will need another newton step\n"
  "    return 0;\n"
  "}\n";

const char* casadi_bound_consistency_str =
  "// NOLINT(legal/copyright)\n"
  "// C-REPLACE \"fmax\" \"casadi_fmax\"\n"
  "// C-REPLACE \"fmin\" \"casadi_fmin\"\n"
  "// C-REPLACE \"std::isinf\" \"casadi_isinf\"\n"
  "// SYMBOL \"bound_consistency\"\n"
  "template<typename T1>\n"
  "void casadi_bound_consistency(casadi_int n, T1* x, T1* lam,\n"
  "                                 const T1* lbx, const T1* ubx) {\n"
  "    // Local variables\n"
  "    casadi_int i;\n"
  "    T1 lb, ub;\n"
  "    // Loop over variables\n"
  "    for (i=0; i<n; ++i) {\n"
  "      // Get bounds\n"
  "      lb = lbx ? lbx[i] : 0.;\n"
  "      ub = ubx ? ubx[i] : 0.;\n"
  "      // Make sure bounds are respected\n"
  "      x[i] = fmin(fmax(x[i], lb), ub);\n"
  "      // Adjust multipliers\n"
  "      if (std::isinf(lb) && std::isinf(ub)) {\n"
  "        // Both multipliers are infinite\n"
  "        lam[i] = 0.;\n"
  "      } else if (std::isinf(lb) || x[i] - lb > ub - x[i]) {\n"
  "        // Infinite lower bound or closer to upper bound than lower bound\n"
  "        lam[i] = fmax(0., lam[i]);\n"
  "      } else if (std::isinf(ub) || x[i] - lb < ub - x[i]) {\n"
  "        // Infinite upper bound or closer to lower bound than upper bound\n"
  "        lam[i] = fmin(0., lam[i]);\n"
  "      }\n"
  "    }\n"
  "}\n";

const char* casadi_lsqr_str =
  "// C-REPLACE \"fabs\" \"casadi_fabs\"\n"
  "// C-REPLACE \"sign\" \"casadi_sign\"\n"
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"lsqr_sym_ortho\"\n"
  "template<typename T1>\n"
  "void casadi_lsqr_sym_ortho(T1 a, T1 b, T1* cs, T1* sn, T1* rho) {\n"
  "    T1 tau;\n"
  "    if (b == 0) {\n"
  "        *cs = sign(a);\n"
  "        *sn = 0;\n"
  "        *rho = fabs(a);\n"
  "    } else if (a==0) {\n"
  "        *cs = 0;\n"
  "        *sn = sign(b);\n"
  "        *rho = fabs(b);\n"
  "    } else if (fabs(b)>fabs(a)) {\n"
  "        tau = a/b;\n"
  "        *sn = sign(b)/sqrt(1+tau*tau);\n"
  "        *cs = (*sn)*tau;\n"
  "        *rho = b/(*sn);\n"
  "    } else {\n"
  "        tau = b/a;\n"
  "        *cs = sign(a)/sqrt(1+tau*tau);\n"
  "        *sn = (*cs)*tau;\n"
  "        *rho = a/(*cs);\n"
  "    }\n"
  "}\n"
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"lsqr_single_solve\"\n"
  "// Ref: scipy\n"
  "template<typename T1>\n"
  "int casadi_lsqr_single_solve(const T1* A, T1* x, casadi_int tr, const casadi_int* sp, T1* w) {\n"
  "    casadi_int m, n, i;\n"
  "    T1 damp, atol, btol, conlim, ctol, anorm, acond, dampsq, ddnorm, res2, xnorm, xxnorm, z;\n"
  "    T1 cs2, sn2, alpha, beta, rhobar, phibar, bnorm, rnorm, arnorm, rhobar1, cs1, sn1, psi;\n"
  "    T1 cs, sn, rho, theta, phi, tau, t1, t2, n2dk, delta, gambar, rhs, zbar, gamma, res1;\n"
  "    T1 r1sq, r1norm, test1, test2, test3, rtol;\n"
  "    casadi_int iter_lim, itn, istop;\n"
  "    T1 *u, *v, *xx, *ww, *dk;\n"
  "    m = sp[0];\n"
  "    n = sp[1];\n"
  "    damp = 0;\n"
  "    atol = 1e-15;\n"
  "    btol = 1e-15;\n"
  "    conlim = 1e8;\n"
  "    iter_lim = 10000;\n"
  "    itn = 0;\n"
  "    istop = 0;\n"
  "    ctol = 0;\n"
  "    if (conlim > 0) ctol = 1/conlim;\n"
  "    anorm = 0;\n"
  "    acond = 0;\n"
  "    dampsq = damp*damp;\n"
  "    ddnorm = 0;\n"
  "    res2 = 0;\n"
  "    xnorm = 0;\n"
  "    xxnorm = 0;\n"
  "    z = 0;\n"
  "    cs2 = -1;\n"
  "    sn2 = 0;\n"
  "    u = w;  w+= m; casadi_copy(x, m, u);\n"
  "    v = w;  w+= n; casadi_clear(v, n);\n"
  "    xx = w; w+= n; casadi_clear(xx, n);\n"
  "    ww = w; w+= n; casadi_clear(v, n);\n"
  "    dk = w; w+= n;\n"
  "    alpha = 0;\n"
  "    beta = casadi_norm_2(m, u);\n"
  "    if (beta>0) {\n"
  "      for (i=0;i<m;++i) u[i]*=1/beta;\n"
  "      casadi_mv(A, sp, u, v, !tr);\n"
  "      alpha = casadi_norm_2(n, v);\n"
  "    }\n"
  "    if (alpha>0) {\n"
  "      for (i=0;i<n;++i) v[i]*=1/alpha;\n"
  "      casadi_copy(v, n, ww);\n"
  "    }\n"
  "    rhobar = alpha;\n"
  "    phibar = beta;\n"
  "    bnorm = beta;\n"
  "    rnorm = beta;\n"
  "    arnorm = alpha * beta;\n"
  "    while (itn<iter_lim) {\n"
  "      itn++;\n"
  "      for (i=0;i<m;++i) u[i]*=-alpha;\n"
  "      casadi_mv(A, sp, v, u, tr);\n"
  "      beta = casadi_norm_2(m, u);\n"
  "      if (beta>0) {\n"
  "        for (i=0;i<m;++i) u[i]*=1/beta;\n"
  "        anorm = sqrt(anorm*anorm + alpha*alpha+beta*beta+damp*damp);\n"
  "        for (i=0;i<n;++i) v[i]*=-beta;\n"
  "        casadi_mv(A, sp, u, v, !tr);\n"
  "        alpha = casadi_norm_2(n, v);\n"
  "        if (alpha>0) for (i=0;i<n;++i) v[i]*=1/alpha;\n"
  "      }\n"
  "      rhobar1 = sqrt(rhobar*rhobar+damp*damp);\n"
  "      cs1 = rhobar / rhobar1;\n"
  "      sn1 = damp / rhobar1;\n"
  "      psi = sn1 * phibar;\n"
  "      phibar *= cs1;\n"
  "      casadi_lsqr_sym_ortho(rhobar1, beta, &cs, &sn, &rho);\n"
  "      theta = sn * alpha;\n"
  "      rhobar = -cs * alpha;\n"
  "      phi = cs * phibar;\n"
  "      phibar *= sn;\n"
  "      tau = sn * phi;\n"
  "      t1 = phi / rho;\n"
  "      t2 = -theta / rho;\n"
  "      for (i=0;i<n;++i) dk[i]=ww[i]/rho;\n"
  "      for (i=0; i<n; ++i) xx[i] += t1*ww[i];\n"
  "      for (i=0; i<n; ++i) ww[i] = v[i] + t2*ww[i];\n"
  "      n2dk = casadi_norm_2(n, dk);\n"
  "      ddnorm += n2dk*n2dk;\n"
  "      delta = sn2 * rho;\n"
  "      gambar = -cs2 * rho;\n"
  "      rhs = phi - delta * z;\n"
  "      zbar = rhs / gambar;\n"
  "      xnorm = sqrt(xxnorm + zbar*zbar);\n"
  "      gamma = sqrt(gambar*gambar + theta*theta);\n"
  "      cs2 = gambar / gamma;\n"
  "      sn2 = theta / gamma;\n"
  "      z = rhs / gamma;\n"
  "      xxnorm += z*z;\n"
  "      acond = anorm * sqrt(ddnorm);\n"
  "      res1 = phibar*phibar;\n"
  "      res2 += psi*psi;\n"
  "      rnorm = sqrt(res1+res2);\n"
  "      arnorm = alpha*fabs(tau);\n"
  "      r1sq = rnorm*rnorm - dampsq * xxnorm;\n"
  "      r1norm = sqrt(fabs(r1sq));\n"
  "      if (r1sq < 0) r1norm = -r1norm;\n"
  "      test1 = rnorm / bnorm;\n"
  "      test2 = arnorm / (anorm * rnorm);\n"
  "      test3 = 1 / acond;\n"
  "      t1 = test1 / (1 + anorm * xnorm / bnorm);\n"
  "      rtol = btol + atol * anorm * xnorm / bnorm;\n"
  "      if (itn >= iter_lim) istop = 7;\n"
  "      if (1 + test3 <= 1) istop = 6;\n"
  "      if (1 + test2 <= 1) istop = 5;\n"
  "      if (1 + t1 <= 1) istop = 4;\n"
  "      if (test3 <= ctol) istop = 3;\n"
  "      if (test2 <= atol) istop = 2;\n"
  "      if (test1 <= rtol) istop = 1;\n"
  "      if (istop != 0) break;\n"
  "    }\n"
  "    casadi_copy(xx, m, x);\n"
  "    return 0;\n"
  "}\n"
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"lsqr_solve\"\n"
  "template<typename T1>\n"
  "int casadi_lsqr_solve(const T1* A, T1* x, casadi_int nrhs, casadi_int tr,\n"
  "        const casadi_int* sp, T1* w) {\n"
  "    casadi_int i;\n"
  "    for (i=0; i<nrhs;++i) {\n"
  "      if (casadi_lsqr_single_solve(A, x+i*sp[1], tr, sp, w)) return 1;\n"
  "    }\n"
  "    return 0;\n"
  "}\n";

const char* casadi_cache_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"cache_check\"\n"
  "template<typename T1>\n"
  "int cache_check(const T1* key, T1* cache, int* loc, casadi_int stride, casadi_int sz, casadi_int key_sz, T1** val) { // NOLINT(whitespace/line_length)\n"
  "    char match;\n"
  "    int i, c;\n"
  "    casadi_int k;\n"
  "    T1 *lkey;\n"
  "    // Walk through cache locations\n"
  "    for (i=0;i<sz;++i) {\n"
  "      match = 1;\n"
  "      if (loc[i]<0) { // Never filled\n"
  "        loc[i] = i;\n"
  "        *val = cache + i*stride;\n"
  "        break;\n"
  "      } else {\n"
  "        *val = cache + loc[i]*stride;\n"
  "        // Check for a key hit\n"
  "        lkey = *val;\n"
  "        for (k=0;k<key_sz;++k) {\n"
  "          if (lkey[k]!=key[k]) {\n"
  "            match = 0;\n"
  "            break;\n"
  "          }\n"
  "        }\n"
  "      }\n"
  "      if (match) {\n"
  "        // Move current location to front\n"
  "        c = loc[i];\n"
  "        for (k=i;k>0;--k) loc[k] = loc[k-1];\n"
  "        loc[0] = c;\n"
  "        // Indicate cache hit\n"
  "        return 1;\n"
  "      }\n"
  "    }\n"
  "    // Indicate cache miss\n"
  "    return 0;\n"
  "}\n";

const char* casadi_convexify_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"convexify_strategy_t\"\n"
  "typedef enum {\n"
  "  CVX_REGULARIZE,\n"
  "  CVX_EIGEN_CLIP,\n"
  "  CVX_EIGEN_REFLECT\n"
  "} casadi_convexify_strategy_t;\n"
  "// SYMBOL \"convexify_type_in_t\"\n"
  "typedef enum {\n"
  "  CVX_SYMM, CVX_TRIL, CVX_TRIU\n"
  "} casadi_convexify_type_in_t;\n"
  "// SYMBOL \"convexify_config\"\n"
  "template<typename T1>\n"
  "struct casadi_convexify_config {\n"
  "  casadi_convexify_strategy_t strategy;\n"
  "  casadi_convexify_type_in_t type_in;\n"
  "  const casadi_int * Hsp;\n"
  "  const casadi_int * Hrsp;\n"
  "  T1 margin;\n"
  "  // Projection of Hessian sparsity needed? (cache)\n"
  "  int Hsp_project;\n"
  "  // Reordering of Hessian needed for scc? (cache)\n"
  "  int scc_transform;\n"
  "  /// Block structure of Hessian for certain convexification methods\n"
  "  const casadi_int *scc_offset;\n"
  "  const casadi_int *scc_mapping;\n"
  "  casadi_int scc_offset_size;\n"
  "  /// For eigen-* convexification strategies: maximum iterations for symmetric Schur decomposition\n"
  "  // Needs to be \"big enough\"\n"
  "  casadi_int max_iter_eig;\n"
  "  int verbose;\n"
  "};\n"
  "// C-REPLACE \"casadi_convexify_config<T1>\" \"struct casadi_convexify_config\"\n"
  "// SYMBOL \"convexify_eval\"\n"
  "template<typename T1>\n"
  "int convexify_eval(const casadi_convexify_config<T1>* c, const T1* Hin, T1* Hout, casadi_int* iw, T1* w) { // NOLINT(whitespace/line_length)\n"
  "    casadi_int i, j, k, kk, block_size, offset;\n"
  "    int ret;\n"
  "    T1 reg, e;\n"
  "    T1 *H_block, *w_cvx;\n"
  "    casadi_int Hrsp_nnz = c->Hrsp[2+c->Hrsp[1]];\n"
  "    casadi_int nnz = c->Hsp[2+c->Hsp[1]];\n"
  "    if (c->Hsp_project) {\n"
  "      if (Hin==Hout) {\n"
  "        casadi_copy(Hin, Hrsp_nnz, w);\n"
  "        casadi_project(w, c->Hrsp, Hout, c->Hsp, w+Hrsp_nnz);\n"
  "      } else {\n"
  "        casadi_project(Hin, c->Hrsp, Hout, c->Hsp, w);\n"
  "      }\n"
  "    } else {\n"
  "      if (Hin!=Hout) casadi_copy(Hin, nnz, Hout);\n"
  "    }\n"
  "    if (c->strategy==CVX_REGULARIZE) {\n"
  "      // Determing regularization parameter with Gershgorin theorem\n"
  "      reg = c->margin-casadi_lb_eig(c->Hsp, Hout);\n"
  "      if (reg > 0) casadi_regularize(c->Hsp, Hout, reg);\n"
  "    } else if (c->strategy==CVX_EIGEN_REFLECT || c->strategy==CVX_EIGEN_CLIP) {\n"
  "      offset = 0;\n"
  "      // Loop over Hessian blocks\n"
  "      for (k=0;k<c->scc_offset_size-1;++k) {\n"
  "        block_size = c->scc_offset[k+1]-c->scc_offset[k];\n"
  "        H_block = w;\n"
  "        w_cvx = w;\n"
  "        // Set w_cvx to dense Hessian block from Hout\n"
  "        if (c->scc_transform) {\n"
  "          kk=0;\n"
  "          if (c->type_in==CVX_SYMM) {\n"
  "            // Loop over columns of block\n"
  "            for (i=0;i<block_size;++i) {\n"
  "              // Loop over elements in column\n"
  "              for (j=0;j<block_size;++j, ++kk) {\n"
  "                H_block[kk] = Hout[c->scc_mapping[offset+kk]];\n"
  "              }\n"
  "            }\n"
  "          } else if (c->type_in==CVX_TRIU) {\n"
  "            // Loop over columns of block\n"
  "            for (i=0;i<block_size;++i) {\n"
  "              // Loop over elements in column\n"
  "              for (j=0;j<i+1;++j, ++kk) {\n"
  "                  e = Hout[c->scc_mapping[offset+kk]];\n"
  "                  H_block[i*block_size+j] = e;\n"
  "                  H_block[i+block_size*j] = e;\n"
  "              }\n"
  "            }\n"
  "          } else {\n"
  "            // Loop over columns of block\n"
  "            for (i=0;i<block_size;++i) {\n"
  "              for (j=i;j<block_size;++j, ++kk) {\n"
  "                e = Hout[c->scc_mapping[offset+kk]];\n"
  "                H_block[i*block_size+j] = e;\n"
  "                H_block[i+block_size*j] = e;\n"
  "              }\n"
  "            }\n"
  "          }\n"
  "          w_cvx += block_size*block_size;\n"
  "        } else {\n"
  "          H_block = Hout+offset;\n"
  "        }\n"
  "        // Perform convexification\n"
  "        ret = casadi_cvx(block_size, H_block, c->margin, 1e-10,\n"
  "          c->strategy==CVX_EIGEN_REFLECT, c->max_iter_eig, w_cvx, iw);\n"
  "        if (ret) return ret;\n"
  "        // Fill in upper-rectangular part\n"
  "        for (i=0;i<block_size;++i) {\n"
  "          for (j=0;j<i+1;++j) {\n"
  "            H_block[block_size*i+j] = H_block[block_size*j+i];\n"
  "          }\n"
  "        }\n"
  "        // Put results back in Hout\n"
  "        if (c->scc_transform) {\n"
  "          kk=0;\n"
  "          if (c->type_in==CVX_SYMM) {\n"
  "            // Loop over columns of block\n"
  "            for (i=0;i<block_size;++i) {\n"
  "              // Loop over elements in column\n"
  "              for (j=0;j<block_size;++j, ++kk) {\n"
  "                Hout[c->scc_mapping[offset+kk]] = H_block[kk];\n"
  "              }\n"
  "            }\n"
  "          } else if (c->type_in==CVX_TRIU) {\n"
  "            // Loop over columns of block\n"
  "            for (i=0;i<block_size;++i) {\n"
  "              // Loop over elements in column\n"
  "              for (j=0;j<i+1;++j, ++kk) {\n"
  "                Hout[c->scc_mapping[offset+kk]] = H_block[block_size*i+j];\n"
  "              }\n"
  "            }\n"
  "          } else {\n"
  "            // Loop over columns of block\n"
  "            for (i=0;i<block_size;++i) {\n"
  "              // Loop over elements in column\n"
  "              for (j=i;j<block_size;++j, ++kk) {\n"
  "                Hout[c->scc_mapping[offset+kk]] = H_block[block_size*i+j];\n"
  "              }\n"
  "            }\n"
  "          }\n"
  "        }\n"
  "        if (c->type_in==CVX_SYMM) {\n"
  "          offset += block_size*block_size;\n"
  "        } else {\n"
  "          offset += block_size*(block_size+1)/2;\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "    return 0;\n"
  "  }\n";

const char* casadi_to_mex_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"to_mex\"\n"
  "template<typename T1>\n"
  "mxArray* casadi_to_mex(const casadi_int* sp, const T1* x) {\n"
  "  casadi_int nrow, ncol, c, k;\n"
  "#ifndef CASADI_MEX_NO_SPARSE\n"
  "  casadi_int nnz;\n"
  "#endif\n"
  "  const casadi_int *colind, *row;\n"
  "  mxArray *p;\n"
  "  double *d;\n"
  "#ifndef CASADI_MEX_NO_SPARSE\n"
  "  casadi_int i;\n"
  "  mwIndex *j;\n"
  "#endif /* CASADI_MEX_NO_SPARSE */\n"
  "  nrow = *sp++;\n"
  "  ncol = *sp++;\n"
  "  colind = sp;\n"
  "  row = sp+ncol+1;\n"
  "#ifndef CASADI_MEX_NO_SPARSE\n"
  "  nnz = sp[ncol];\n"
  "  if (nnz!=nrow*ncol) {\n"
  "    p = mxCreateSparse(nrow, ncol, nnz, mxREAL);\n"
  "    for (i=0, j=mxGetJc(p); i<=ncol; ++i) *j++ = *colind++;\n"
  "    for (i=0, j=mxGetIr(p); i<nnz; ++i) *j++ = *row++;\n"
  "    if (x) {\n"
  "      d = (double*)mxGetData(p);\n"
  "      for (i=0; i<nnz; ++i) *d++ = casadi_to_double(*x++);\n"
  "    }\n"
  "    return p;\n"
  "  }\n"
  "#endif /* CASADI_MEX_NO_SPARSE */\n"
  "  p = mxCreateDoubleMatrix(nrow, ncol, mxREAL);\n"
  "  if (x) {\n"
  "    d = (double*)mxGetData(p);\n"
  "    for (c=0; c<ncol; ++c) {\n"
  "      for (k=colind[c]; k<colind[c+1]; ++k) {\n"
  "        d[row[k]+c*nrow] = casadi_to_double(*x++);\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  return p;\n"
  "}\n";

const char* casadi_from_mex_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"from_mex\"\n"
  "template<typename T1>\n"
  "T1* casadi_from_mex(const mxArray* p, T1* y, const casadi_int* sp, T1* w) {\n"
  "  casadi_int nrow, ncol, is_sparse, c, k, p_nrow, p_ncol;\n"
  "  const casadi_int *colind, *row;\n"
  "  mwIndex *Jc, *Ir;\n"
  "  const double* p_data;\n"
  "  if (!mxIsDouble(p) || mxGetNumberOfDimensions(p)!=2)\n"
  "    mexErrMsgIdAndTxt(\"Casadi:RuntimeError\",\n"
  "      \"\\\"from_mex\\\" failed: Not a two-dimensional matrix of double precision.\");\n"
  "  nrow = *sp++;\n"
  "  ncol = *sp++;\n"
  "  colind = sp;\n"
  "  row = sp+ncol+1;\n"
  "  p_nrow = mxGetM(p);\n"
  "  p_ncol = mxGetN(p);\n"
  "  is_sparse = mxIsSparse(p);\n"
  "  Jc = 0;\n"
  "  Ir = 0;\n"
  "  if (is_sparse) {\n"
  "    Jc = mxGetJc(p);\n"
  "    Ir = mxGetIr(p);\n"
  "  }\n"
  "  p_data = (const double*)mxGetData(p);\n"
  "  if (p_nrow==1 && p_ncol==1) {\n"
  "    casadi_int nnz;\n"
  "    double v = is_sparse && Jc[1]==0 ? 0 : *p_data;\n"
  "    nnz = sp[ncol];\n"
  "    casadi_fill(y, nnz, v);\n"
  "  } else {\n"
  "    casadi_int tr = 0;\n"
  "    if (nrow!=p_nrow || ncol!=p_ncol) {\n"
  "      tr = nrow==p_ncol && ncol==p_nrow && (nrow==1 || ncol==1);\n"
  "      if (!tr) mexErrMsgIdAndTxt(\"Casadi:RuntimeError\",\n"
  "                                 \"\\\"from_mex\\\" failed: Dimension mismatch. \"\n"
  "                                 \"Expected %d-by-%d, got %d-by-%d instead.\",\n"
  "                                 nrow, ncol, p_nrow, p_ncol);\n"
  "    }\n"
  "    if (is_sparse) {\n"
  "      if (tr) {\n"
  "        for (c=0; c<ncol; ++c)\n"
  "          for (k=colind[c]; k<colind[c+1]; ++k) w[row[k]+c*nrow]=0;\n"
  "        for (c=0; c<p_ncol; ++c)\n"
  "          for (k=Jc[c]; k<(casadi_int) Jc[c+1]; ++k) w[c+Ir[k]*p_ncol] = p_data[k];\n"
  "        for (c=0; c<ncol; ++c)\n"
  "          for (k=colind[c]; k<colind[c+1]; ++k) y[k] = w[row[k]+c*nrow];\n"
  "      } else {\n"
  "        for (c=0; c<ncol; ++c) {\n"
  "          for (k=colind[c]; k<colind[c+1]; ++k) w[row[k]]=0;\n"
  "          for (k=Jc[c]; k<(casadi_int) Jc[c+1]; ++k) w[Ir[k]]=p_data[k];\n"
  "          for (k=colind[c]; k<colind[c+1]; ++k) y[k]=w[row[k]];\n"
  "        }\n"
  "      }\n"
  "    } else {\n"
  "      for (c=0; c<ncol; ++c) {\n"
  "        for (k=colind[c]; k<colind[c+1]; ++k) {\n"
  "          y[k] = p_data[row[k]+c*nrow];\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  return y;\n"
  "}\n";

